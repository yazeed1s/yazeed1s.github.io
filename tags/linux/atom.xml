<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Yazeed&#x27;s Blog - Linux</title>
    <subtitle>Notes on systems and low-level software.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://yazeed1s.github.io/tags/linux/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://yazeed1s.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2026-02-01T00:00:00+00:00</updated>
    <id>https://yazeed1s.github.io/tags/linux/atom.xml</id>
    <entry xml:lang="en">
        <title>Debugged a Broken Monitor (It Was a Shadow)</title>
        <published>2026-02-01T00:00:00+00:00</published>
        <updated>2026-02-01T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://yazeed1s.github.io/posts/my-monitor-was-dying/"/>
        <id>https://yazeed1s.github.io/posts/my-monitor-was-dying/</id>
        
        <content type="html" xml:base="https://yazeed1s.github.io/posts/my-monitor-was-dying/">&lt;p&gt;I bought a new dell monitor. A few days in, I noticed a dim shadow in the top-left corner. Sometimes it stretched briefly on power-on.&lt;&#x2F;p&gt;
&lt;p&gt;It looked &lt;strong&gt;&lt;em&gt;physical&lt;&#x2F;em&gt;&lt;&#x2F;strong&gt;. Like panel uniformity issues. Like backlight bleed. Like I bought a defective monitor.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;hardware-spiral&quot;&gt;hardware spiral&lt;&#x2F;h2&gt;
&lt;p&gt;when you see a corner darkening, you blame everything physical:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;monitor arm (did i twist the panel?)&lt;&#x2F;li&gt;
&lt;li&gt;backlight &#x2F; diffuser&lt;&#x2F;li&gt;
&lt;li&gt;cable &#x2F; port&lt;&#x2F;li&gt;
&lt;li&gt;the monitor itself&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I ran through the usual checks. built-in diagnostics were clean. different cables didn&#x27;t help. the shadow just sat there, stable, looking like it belonged to the panel.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;wrong-rabbit-hole&quot;&gt;wrong rabbit hole&lt;&#x2F;h2&gt;
&lt;p&gt;Same day this started, I was messing with &lt;code&gt;tlp&lt;&#x2F;code&gt; and &lt;code&gt;auto-cpufreq&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;So naturally: &quot;did I power-save my way into a broken display?&quot;. So I turned it all off. and the shadow stayed!!&lt;&#x2F;p&gt;
&lt;p&gt;At least now I knew it wasn&#x27;t some weird power profile.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;software-suspects&quot;&gt;software suspects&lt;&#x2F;h2&gt;
&lt;p&gt;My stack started looking suspicious:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;custom window manager&lt;&#x2F;li&gt;
&lt;li&gt;x11&lt;&#x2F;li&gt;
&lt;li&gt;picom (shadows, damage tracking, the usual &quot;maybe it&#x27;s stale buffers&quot;)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Nothing in that layer had changed recently though. No updates, no config changes. Not proof, but enough to stop me from rewriting compositor configs at 2am.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;isolation&quot;&gt;isolation&lt;&#x2F;h2&gt;
&lt;p&gt;I logged into wayland. Shadow gone. same laptop. same cable. same monitor.&lt;&#x2F;p&gt;
&lt;p&gt;That&#x27;s when I stopped worrying about RMA. wayland wasn&#x27;t &quot;better&quot; here, it was just a control group.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;bisect&quot;&gt;bisect&lt;&#x2F;h2&gt;
&lt;p&gt;Once I knew it was x11 and not the monitor, I thought about what actually changed.&lt;&#x2F;p&gt;
&lt;p&gt;I had recently updated my window manager.
Laziest possible bisect:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;switch to x11 -&amp;gt; artifact returns&lt;&#x2F;li&gt;
&lt;li&gt;roll back WM -&amp;gt; artifact gone&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This was a regression I introduced.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;the-reveal&quot;&gt;the reveal&lt;&#x2F;h2&gt;
&lt;p&gt;Turns out I didn&#x27;t mess up stacking order, I actually implemented it correctly. EWMH says window types stack in a specific order, and &lt;code&gt;polybar&lt;&#x2F;code&gt; (type &lt;code&gt;_NET_WM_TYPE_DOCK&lt;&#x2F;code&gt;) now sat above basically everything.&lt;&#x2F;p&gt;
&lt;p&gt;I run picom with shadows. polybar now had a shadow that landed on top of other windows.&lt;&#x2F;p&gt;
&lt;p&gt;On firefox or any bright window near that corner, it looked exactly like panel dimming.&lt;&#x2F;p&gt;
&lt;p&gt;The funniest thing is that the bar wasn&#x27;t even on the external monitor. Only its shadow was.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;why-the-shadow-landed-on-the-other-monitor&quot;&gt;why the shadow landed on the other monitor&lt;&#x2F;h2&gt;
&lt;p&gt;My laptop screen has polybar. External monitor doesn&#x27;t.&lt;&#x2F;p&gt;
&lt;p&gt;But x11 treats the desktop as one big coordinate space. Monitors are just rectangles inside it:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);&quot;&gt;&lt;code data-lang=&quot;shellscript&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; xrandr&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; -&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt;-listmonitors&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;Monitors:&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 2&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; 0:&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; +&lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;eDP&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; 1920&#x2F;302x1200&#x2F;189+0+0&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;  eDP&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; 1:&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; +DisplayPort-0&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; 2560&#x2F;597x1440&#x2F;336+1920+0&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;  DisplayPort-0&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;external starts at &lt;code&gt;x = 1920&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;shadows don&#x27;t care about monitor boundaries. just pixels in global space. if you blur something near the right edge of the laptop screen, that blur can spill into the left edge of the external monitor.&lt;&#x2F;p&gt;
&lt;p&gt;which is exactly where i was seeing the &quot;hardware defect.&quot;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;confirmation&quot;&gt;confirmation&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;killed-polybar-dimming-gone-instantly&quot;&gt;Killed polybar. dimming gone instantly.&lt;&#x2F;h2&gt;
&lt;h2 id=&quot;the-fix&quot;&gt;the fix&lt;&#x2F;h2&gt;
&lt;p&gt;Make sure polybar doesn&#x27;t cast shadows. Fake hardware defect never came back.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;notes&quot;&gt;notes&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;this doesn&#x27;t generalize to &quot;it&#x27;s always software.&quot; panels do fail. but isolating layers beats spiraling.&lt;&#x2F;li&gt;
&lt;li&gt;multi-monitor on x11 is one big canvas. effects don&#x27;t stop at the seam unless you make them.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Infiniswap: Remote Memory Paging Over RDMA</title>
        <published>2026-01-18T00:00:00+00:00</published>
        <updated>2026-01-18T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://yazeed1s.github.io/posts/infiniswap/"/>
        <id>https://yazeed1s.github.io/posts/infiniswap/</id>
        
        <content type="html" xml:base="https://yazeed1s.github.io/posts/infiniswap/">&lt;hr &#x2F;&gt;
&lt;p&gt;I came across this paper while looking into memory disaggregation. The idea is deceptively simple: when a machine runs out of RAM, instead of paging to disk, page to another machine&#x27;s unused memory over the network.&lt;&#x2F;p&gt;
&lt;p&gt;What caught my attention is &lt;em&gt;how&lt;&#x2F;em&gt; they pulled it off; no application changes, no core kernel patching. It&#x27;s a kernel module that hooks into Linux&#x27;s swap path and uses remote RAM as the fast tier, with disk as fallback.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;the-core-idea&quot;&gt;the core idea&lt;&#x2F;h2&gt;
&lt;p&gt;Production clusters waste a lot of memory. Some machines are memory-starved while others sit idle. The 99th percentile machine often uses 2-3× more memory than the median. Meanwhile, over half the cluster&#x27;s aggregate memory goes unused.&lt;&#x2F;p&gt;
&lt;p&gt;When applications can&#x27;t fit their working set in RAM, performance falls off a cliff. VoltDB drops from 95K TPS to 4K TPS. Memcached&#x27;s tail latency shoots up 21×. Disk is too slow to help (1000× slower than memory).&lt;&#x2F;p&gt;
&lt;p&gt;Infiniswap&#x27;s insight: RDMA networks give you single-digit microsecond latencies. That&#x27;s fast enough to make remote memory a viable swap target. Instead of page -&amp;gt; disk, you do page -&amp;gt; remote RAM over RDMA. The remote CPU stays out of the data movement; the RNIC does the DMA.&lt;&#x2F;p&gt;
&lt;p&gt;The result: swap that looks normal to Linux, but is backed by slabs of remote memory scattered across the cluster.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;what-s-clever&quot;&gt;what&#x27;s clever&lt;&#x2F;h2&gt;
&lt;p&gt;A few design choices stood out:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Using swap as the integration point.&lt;&#x2F;strong&gt; Instead of modifying the kernel&#x27;s page fault handler or remapping virtual memory, Infiniswap plugs into Linux&#x27;s existing swap subsystem. The kernel already knows how to page out and page back in. Infiniswap just changes where those swapped pages live. The trade-off is you&#x27;re still going through the swap path (page faults, context switches, the whole thing) but you get deployment simplicity.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;One-sided RDMA.&lt;&#x2F;strong&gt; Traditional network block devices (like Mellanox&#x27;s nbdX) use send&#x2F;recv semantics. The remote CPU has to wake up, copy data, respond. Infiniswap uses RDMA_READ and RDMA_WRITE (the RNIC directly accesses remote memory without running remote code on the critical path). The paper shows nbdX burns multiple vCPUs on the remote side; Infiniswap largely avoids that.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Slab-based design.&lt;&#x2F;strong&gt; Pages are grouped into 1GB slabs. Each slab maps to one remote machine. This keeps the metadata manageable (tracking millions of individual 4KB pages across the cluster would be expensive). When a slab gets &quot;hot&quot; (&amp;gt;20 page I&#x2F;O ops&#x2F;sec), it gets mapped to remote memory. Cold slabs stay on disk.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;where-it-works&quot;&gt;where it works&lt;&#x2F;h2&gt;
&lt;p&gt;Memory-bound workloads see big wins. Memcached stays nearly flat even when only 50% of the working set fits in memory. PowerGraph runs 6.5× faster. VoltDB, while CPU-heavy, still sees 15× throughput improvement over disk.&lt;&#x2F;p&gt;
&lt;p&gt;The cluster memory utilization goes from 40% to 60% (that&#x27;s 47% more effective use of RAM, with minimal network overhead (&amp;lt;1% of capacity)).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;where-it-doesn-t&quot;&gt;where it doesn&#x27;t&lt;&#x2F;h2&gt;
&lt;p&gt;CPU-bound workloads don&#x27;t benefit as much. VoltDB and Spark already run at high CPU utilization. Adding paging overhead (context switches, TLB flushes, page table walks) eats into that. Spark at 50% memory thrashes so badly it doesn&#x27;t complete.&lt;&#x2F;p&gt;
&lt;p&gt;The fundamental limit: this isn&#x27;t local memory. Page faults still happen. You&#x27;re masking latency, not eliminating it. For workloads where microseconds matter deterministically, that&#x27;s a problem.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;notes&quot;&gt;notes&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Paper: &lt;a rel=&quot;external&quot; href=&quot;https:&#x2F;&#x2F;www.usenix.org&#x2F;system&#x2F;files&#x2F;conference&#x2F;nsdi17&#x2F;nsdi17-gu.pdf&quot;&gt;Gu et al., &quot;Efficient Memory Disaggregation with Infiniswap&quot;, NSDI 2017&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Tested on 32 machines, 56 Gbps Infiniband, 64GB RAM each&lt;&#x2F;li&gt;
&lt;li&gt;Slab placement uses &quot;power of two choices&quot; (pick two random machines, query free memory, map to the one with more headroom)&lt;&#x2F;li&gt;
&lt;li&gt;Slab eviction queries E+5 machines, evicts the coldest from that set (~363μs median)&lt;&#x2F;li&gt;
&lt;li&gt;Page-out: synchronous RDMA_WRITE + async disk write (disk is fallback if remote crashes)&lt;&#x2F;li&gt;
&lt;li&gt;Page-in: check bitmap -&amp;gt; RDMA_READ if remote, else read from disk&lt;&#x2F;li&gt;
&lt;li&gt;Slab remapping after failure takes ~54ms (Infiniband memory registration)&lt;&#x2F;li&gt;
&lt;li&gt;Default headroom threshold: 8GB per machine&lt;&#x2F;li&gt;
&lt;li&gt;Hot slab threshold: 20 page I&#x2F;O ops&#x2F;sec (EWMA, α=0.2)&lt;&#x2F;li&gt;
&lt;li&gt;Compared to: nbdX (Mellanox), Fastswap (kernel modification), LegoOS (full OS redesign)&lt;&#x2F;li&gt;
&lt;li&gt;Code available on GitHub &lt;a rel=&quot;external&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;SymbioticLab&#x2F;Infiniswap&quot;&gt;SymbioticLab&#x2F;infiniswap&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>What Linux Does When Memory Runs Out</title>
        <published>2025-12-15T00:00:00+00:00</published>
        <updated>2025-12-15T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://yazeed1s.github.io/posts/linux-memory-pressure/"/>
        <id>https://yazeed1s.github.io/posts/linux-memory-pressure/</id>
        
        <content type="html" xml:base="https://yazeed1s.github.io/posts/linux-memory-pressure/">&lt;hr &#x2F;&gt;
&lt;p&gt;When you&#x27;re out of RAM and swap is filling up, Linux has to make hard choices. This post is about what those choices are and why they sometimes end with your process getting killed.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;page-replacement&quot;&gt;page replacement&lt;&#x2F;h2&gt;
&lt;p&gt;When RAM is full and something new needs to come in, something else has to go out. Linux uses LRU lists (active&#x2F;inactive), split for anonymous memory (heap&#x2F;stack) and file-backed pages (page cache). The mental model is the same:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Active list.&lt;&#x2F;strong&gt; Pages that have been accessed recently. These are &quot;hot&quot; (probably still in use).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Inactive list.&lt;&#x2F;strong&gt; Pages that haven&#x27;t been touched in a while. These are candidates for eviction.&lt;&#x2F;p&gt;
&lt;p&gt;New pages usually start inactive. If they get accessed again, they get promoted to active. Reclaim prefers victims from inactive.&lt;&#x2F;p&gt;
&lt;p&gt;This is a rough approximation of LRU (Least Recently Used). True LRU would track exact access times for every page, which is too expensive. Linux settles for &quot;recently used&quot; versus &quot;not recently used.&quot;&lt;&#x2F;p&gt;
&lt;p&gt;When memory pressure rises, the kernel scans pages on the inactive list, looking for victims. Clean pages (unchanged since loaded) can be dropped immediately. Dirty pages have to be written to disk first.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;swap-behavior&quot;&gt;swap behavior&lt;&#x2F;h2&gt;
&lt;p&gt;Swap is the overflow area (disk space where evicted pages go).&lt;&#x2F;p&gt;
&lt;p&gt;Linux doesn&#x27;t wait until RAM is completely full to start swapping. It swaps based on a tunable called &lt;strong&gt;swappiness&lt;&#x2F;strong&gt; (0-200). Roughly, it&#x27;s a knob for how willing the kernel is to swap anonymous memory versus reclaim file cache.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;0&lt;&#x2F;strong&gt; = Avoid swapping anonymous memory unless you have to&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;60&lt;&#x2F;strong&gt; = Default-ish, balanced&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;100+&lt;&#x2F;strong&gt; = Swap more aggressively to keep RAM free for file cache&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);&quot;&gt;&lt;code data-lang=&quot;shellscript&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; cat&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;60&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Higher swappiness means Linux will push application pages to swap earlier to keep more room for file system cache. Lower swappiness keeps your applications in RAM longer but may hurt cache performance.&lt;&#x2F;p&gt;
&lt;p&gt;There&#x27;s no universally right answer. It depends on whether your workload benefits more from cached file data or from keeping application memory resident.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;what-can-t-be-swapped&quot;&gt;what can&#x27;t be swapped&lt;&#x2F;h2&gt;
&lt;p&gt;Not all memory can go to disk.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Kernel memory can&#x27;t be swapped.&lt;&#x2F;strong&gt; The kernel&#x27;s own data structures (page tables, process descriptors, driver state) must stay in RAM. If the kernel itself got paged out, who would page it back in?&lt;&#x2F;p&gt;
&lt;p&gt;Specifically, a lot of kernel allocations live in the direct map (the linear mapping of physical memory into kernel virtual addresses). It&#x27;s still mapped via page tables, but it&#x27;s not pageable like user memory.&lt;&#x2F;p&gt;
&lt;p&gt;This is why memory leaks in kernel code are especially dangerous. That memory is gone until reboot.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;the-oom-killer&quot;&gt;the oom killer&lt;&#x2F;h2&gt;
&lt;p&gt;When both RAM and swap are full and the kernel can&#x27;t reclaim any more memory, Linux invokes the &lt;strong&gt;OOM Killer&lt;&#x2F;strong&gt; (Out Of Memory Killer).&lt;&#x2F;p&gt;
&lt;p&gt;It picks a process and terminates it. No negotiation. Just dead.&lt;&#x2F;p&gt;
&lt;p&gt;How it chooses:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory usage.&lt;&#x2F;strong&gt; Bigger hogs are more likely targets.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;OOM score.&lt;&#x2F;strong&gt; Each process has a computed score, plus a tunable adjustment, that influences selection.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);&quot;&gt;&lt;code data-lang=&quot;shellscript&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; Check a process&amp;#39;s OOM score&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; cat&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; &#x2F;proc&#x2F;1234&#x2F;oom_score&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;582&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; Protect important processes&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; echo&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; -&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt;1000&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; &amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; &#x2F;proc&#x2F;1234&#x2F;oom_score_adj&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Setting &lt;code&gt;oom_score_adj&lt;&#x2F;code&gt; to -1000 makes a process essentially unkillable by the global OOM killer. Set it to +1000 and it becomes a preferred target.&lt;&#x2F;p&gt;
&lt;p&gt;The OOM killer exists because the alternative is worse. Without it, the system would deadlock (no memory to allocate, no way to free any). At least killing one process gives everything else a chance to survive.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;why-linux-overcommits&quot;&gt;why linux overcommits&lt;&#x2F;h2&gt;
&lt;p&gt;By default, Linux allows you to allocate more memory than exists. &lt;code&gt;malloc(1GB)&lt;&#x2F;code&gt; succeeds even if you only have 512MB free.&lt;&#x2F;p&gt;
&lt;p&gt;This is &lt;strong&gt;overcommit&lt;&#x2F;strong&gt;, and it&#x27;s intentional. Most programs allocate way more memory than they use. Sparse arrays, buffers &quot;just in case,&quot; forked processes before exec. If Linux refused these allocations, lots of software would break.&lt;&#x2F;p&gt;
&lt;p&gt;The downside: if you actually try to use all that memory you allocated, you trigger the OOM killer. The allocation succeeded, but using it didn&#x27;t.&lt;&#x2F;p&gt;
&lt;p&gt;You can tune this behavior:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);&quot;&gt;&lt;code data-lang=&quot;shellscript&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; Check current mode&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; cat&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;overcommit_memory&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;  #&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; heuristic (default)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; Options:&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; 0 = heuristic overcommit (kernel guesses what&amp;#39;s safe)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; 1 = always overcommit (never refuse malloc)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; 2 = strict (refuse if total committed memory would exceed a commit limit derived from RAM, swap, and vm.overcommit_ratio &#x2F; vm.overcommit_kbytes)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Mode 2 is safer but breaks more software. Mode 0 is a compromise. Mode 1 is living dangerously.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;what-this-means-practically&quot;&gt;what this means practically&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Mysterious crashes.&lt;&#x2F;strong&gt; If your process dies with no explanation, check &lt;code&gt;dmesg&lt;&#x2F;code&gt; for OOM killer messages. It might not be your bug (Linux might have killed you to save the system).&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Server planning.&lt;&#x2F;strong&gt; On production servers, monitor swap usage. If you&#x27;re consistently in swap, you&#x27;re consistently slow. If swap fills up, the OOM killer is coming.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Memory limits.&lt;&#x2F;strong&gt; Use cgroups to limit how much memory a process can use. Better to have one application fail cleanly than to have the OOM killer pick arbitrarily.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Kernel memory matters.&lt;&#x2F;strong&gt; If kernel memory grows unbounded (driver bug, leak in a module), you can&#x27;t swap it out. Eventually, OOM. Unlike user-space leaks, you can&#x27;t just kill the offending process.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;the-reality&quot;&gt;the reality&lt;&#x2F;h2&gt;
&lt;p&gt;Linux&#x27;s memory management is a set of tradeoffs, not solutions.&lt;&#x2F;p&gt;
&lt;p&gt;Swappiness lets you trade application responsiveness for cache performance. Overcommit lets you trade guaranteed allocation for flexibility. The OOM killer trades one process&#x27;s life for system stability.&lt;&#x2F;p&gt;
&lt;p&gt;None of these are free. The system is designed to keep running as long as possible, even when resources are exhausted. But &quot;running&quot; under memory pressure doesn&#x27;t mean &quot;running well.&quot;&lt;&#x2F;p&gt;
&lt;p&gt;When you see the OOM killer fire, it&#x27;s not a bug. It&#x27;s the kernel doing exactly what it&#x27;s designed to do: making a hard choice so you don&#x27;t have to reboot.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>OS Context Switching: What Happens When Processes Switch</title>
        <published>2025-11-28T00:00:00+00:00</published>
        <updated>2025-11-28T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://yazeed1s.github.io/posts/context-switching/"/>
        <id>https://yazeed1s.github.io/posts/context-switching/</id>
        
        <content type="html" xml:base="https://yazeed1s.github.io/posts/context-switching/">&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;What is a context switch?&lt;&#x2F;li&gt;
&lt;li&gt;Why context switches are necessary&lt;&#x2F;li&gt;
&lt;li&gt;The cost of switching&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;what-gets-saved&quot;&gt;What Gets Saved&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;CPU registers (general purpose, special)&lt;&#x2F;li&gt;
&lt;li&gt;Program counter&lt;&#x2F;li&gt;
&lt;li&gt;Stack pointer&lt;&#x2F;li&gt;
&lt;li&gt;Floating point &#x2F; SIMD state&lt;&#x2F;li&gt;
&lt;li&gt;Memory mappings (page table pointer)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;triggers-for-context-switch&quot;&gt;Triggers for Context Switch&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Timer interrupt (preemption)&lt;&#x2F;li&gt;
&lt;li&gt;System calls&lt;&#x2F;li&gt;
&lt;li&gt;I&#x2F;O blocking&lt;&#x2F;li&gt;
&lt;li&gt;Voluntary yield&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;the-context-switch-process&quot;&gt;The Context Switch Process&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Step-by-step walkthrough&lt;&#x2F;li&gt;
&lt;li&gt;Kernel mode transition&lt;&#x2F;li&gt;
&lt;li&gt;Saving old state&lt;&#x2F;li&gt;
&lt;li&gt;Loading new state&lt;&#x2F;li&gt;
&lt;li&gt;Return to user mode&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;linux-implementation&quot;&gt;Linux Implementation&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;task_struct&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;switch_to()&lt;&#x2F;code&gt; macro&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;schedule()&lt;&#x2F;code&gt; function&lt;&#x2F;li&gt;
&lt;li&gt;Where the actual switch happens&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;performance-impact&quot;&gt;Performance Impact&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Direct costs (saving&#x2F;restoring registers)&lt;&#x2F;li&gt;
&lt;li&gt;Indirect costs (cache pollution, TLB flush)&lt;&#x2F;li&gt;
&lt;li&gt;Measuring context switch overhead&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;reducing-context-switches&quot;&gt;Reducing Context Switches&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;User-space threading (green threads)&lt;&#x2F;li&gt;
&lt;li&gt;Async I&#x2F;O (epoll, io_uring)&lt;&#x2F;li&gt;
&lt;li&gt;CPU affinity&lt;&#x2F;li&gt;
&lt;li&gt;Batching work&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;diagram-ideas&quot;&gt;Diagram Ideas&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Context switch flow&lt;&#x2F;li&gt;
&lt;li&gt;State saved&#x2F;restored&lt;&#x2F;li&gt;
&lt;li&gt;Timeline of a switch&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Context switches are unavoidable but can be minimized&lt;&#x2F;li&gt;
&lt;li&gt;Tradeoffs between responsiveness and throughput&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Linux kernel source (kernel&#x2F;sched&#x2F;)&lt;&#x2F;li&gt;
&lt;li&gt;Operating systems textbooks&lt;&#x2F;li&gt;
&lt;li&gt;Performance measurement tools (perf, ftrace)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Signal Handlers for Cleanup in C Programs</title>
        <published>2023-12-17T00:00:00+00:00</published>
        <updated>2023-12-17T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://yazeed1s.github.io/posts/force-memory-cleanup/"/>
        <id>https://yazeed1s.github.io/posts/force-memory-cleanup/</id>
        
        <content type="html" xml:base="https://yazeed1s.github.io/posts/force-memory-cleanup/">&lt;hr &#x2F;&gt;
&lt;p&gt;In C, you put cleanup code at the end of &lt;code&gt;main()&lt;&#x2F;code&gt; to free your allocations, close your files, etc. But what if your program crashes before reaching that code?&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;&#x2F;h2&gt;
&lt;p&gt;Standard cleanup at the end of main only works if your program exits normally. If it crashes (e.g., a null pointer dereference), the OS raises SIGSEGV and your program dies immediately. Your cleanup code never runs.&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);&quot;&gt;&lt;code data-lang=&quot;c&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#955F3C, #E08F5A);&quot;&gt;include&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;stdio.h&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#955F3C, #E08F5A);&quot;&gt;include&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;stdlib.h&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;char&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; *&lt;&#x2F;span&gt;&lt;span&gt;buffer &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; main&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    buffer &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; malloc&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt;500&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; *&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 1024&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; *&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 1024&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; 500 MB&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    if&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; (&lt;&#x2F;span&gt;&lt;span&gt;buffer &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;        return&lt;&#x2F;span&gt;&lt;span&gt; EXIT_FAILURE&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    printf&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;Allocated 500 MB&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;    &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; oops&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    char&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; *&lt;&#x2F;span&gt;&lt;span&gt;invalid_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    *&lt;&#x2F;span&gt;&lt;span&gt;invalid_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; SIGSEGV here&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;    &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; never reached&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    printf&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;About to cleanup...&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    free&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;buffer&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    return&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 0&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Output:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);&quot;&gt;&lt;code data-lang=&quot;shellscript&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; gcc&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; crash.c&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; -&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt;o&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; crash&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; &amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; .&#x2F;crash&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;Allocated&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 500&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; MB&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;Segmentation&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; fault&lt;&#x2F;span&gt;&lt;span&gt; (core&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt; dumped&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;free(buffer)&lt;&#x2F;code&gt; never runs.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;first-thought-atexit&quot;&gt;First Thought: atexit()&lt;&#x2F;h2&gt;
&lt;p&gt;You might think &lt;code&gt;atexit()&lt;&#x2F;code&gt; solves this:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);&quot;&gt;&lt;code data-lang=&quot;c&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; cleanup&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    free&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;buffer&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; main&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    atexit&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;cleanup&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;    &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; ...&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But &lt;code&gt;atexit()&lt;&#x2F;code&gt; handlers only run on &lt;strong&gt;normal&lt;&#x2F;strong&gt; exit, when main returns or when you call &lt;code&gt;exit()&lt;&#x2F;code&gt;. A signal like SIGSEGV bypasses atexit entirely.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-solution-signal-handlers&quot;&gt;The Solution: Signal Handlers&lt;&#x2F;h2&gt;
&lt;p&gt;To run cleanup code on crash, you register a signal handler:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);&quot;&gt;&lt;code data-lang=&quot;c&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#955F3C, #E08F5A);&quot;&gt;include&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;signal.h&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#955F3C, #E08F5A);&quot;&gt;include&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;stdio.h&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#955F3C, #E08F5A);&quot;&gt;include&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;stdlib.h&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#955F3C, #E08F5A);&quot;&gt;include&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; &amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;unistd.h&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;char&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; *&lt;&#x2F;span&gt;&lt;span&gt;buffer &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; cleanup_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; sig&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;    (&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;sig&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;    &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; Note: using write() instead of printf() - see below&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    const&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; char&lt;&#x2F;span&gt;&lt;span&gt; msg&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;[]&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; =&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;Caught signal, exiting...&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    write&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;STDERR_FILENO&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; msg&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; sizeof&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;msg&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; -&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 1&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;    &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; For crash signals, keep the handler minimal. Most cleanup is not&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;    &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; async-signal-safe, and the kernel will reclaim process memory anyway.&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    _exit&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; use _exit, not exit()&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; main&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;    &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; register handler for crash signals&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    signal&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;SIGSEGV&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; cleanup_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    signal&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;SIGABRT&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; cleanup_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    signal&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;SIGINT&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; cleanup_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;  &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; Ctrl+C&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    signal&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;SIGTERM&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; cleanup_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; kill command&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    buffer &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; malloc&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt;500&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; *&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 1024&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; *&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 1024&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    if&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; (&lt;&#x2F;span&gt;&lt;span&gt;buffer &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;        return&lt;&#x2F;span&gt;&lt;span&gt; EXIT_FAILURE&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    printf&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;Allocated 500 MB&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt;\n&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    char&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt; *&lt;&#x2F;span&gt;&lt;span&gt;invalid_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; NULL&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    *&lt;&#x2F;span&gt;&lt;span&gt;invalid_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; &amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#906E3A, #D8A657);&quot;&gt;x&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; triggers SIGSEGV -&amp;gt; cleanup_handler runs&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    return&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 0&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now when the program crashes, the handler runs first.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;important-async-signal-safety&quot;&gt;Important: Async-Signal-Safety&lt;&#x2F;h2&gt;
&lt;p&gt;There&#x27;s a catch. Signal handlers can interrupt your program at any point, even in the middle of malloc or printf. If your handler then calls malloc or printf, you can deadlock or corrupt memory.&lt;&#x2F;p&gt;
&lt;p&gt;Only certain functions are safe to call from signal handlers. These are called &quot;async-signal-safe&quot; functions. The POSIX standard defines the list. Key ones:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;write()&lt;&#x2F;code&gt; - safe (printf is NOT safe)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;_exit()&lt;&#x2F;code&gt; - safe (exit is NOT safe, it runs atexit handlers)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;close()&lt;&#x2F;code&gt;, &lt;code&gt;unlink()&lt;&#x2F;code&gt;, &lt;code&gt;fsync()&lt;&#x2F;code&gt; - safe&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;free()&lt;&#x2F;code&gt; is &lt;strong&gt;not&lt;&#x2F;strong&gt; async-signal-safe. It might &quot;work&quot; in a toy program, and then deadlock in production because the signal interrupted malloc&#x2F;free internals. Don&#x27;t rely on it.&lt;&#x2F;p&gt;
&lt;p&gt;A safer pattern is to set a flag and let the main program handle cleanup:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);&quot;&gt;&lt;code data-lang=&quot;c&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;volatile&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#576E65, #83A598);&quot;&gt; sig_atomic_t&lt;&#x2F;span&gt;&lt;span&gt; got_signal &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 0&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; handler&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; sig&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    got_signal &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; sig&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; main&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    signal&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;SIGINT&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; handler&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    while&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;got_signal&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;        &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; do work&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;    &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; cleanup here, in normal context&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    cleanup&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    return&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 0&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But for crash signals (SIGSEGV, SIGABRT), you can&#x27;t return to normal execution, the program is already broken. So you do what cleanup you can in the handler and exit.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wait-doesn-t-the-os-clean-up-anyway&quot;&gt;Wait, Doesn&#x27;t the OS Clean Up Anyway?&lt;&#x2F;h2&gt;
&lt;p&gt;Yes. On any modern OS (Linux, macOS, Windows), when your process terminates (normally or not), the kernel reclaims all its resources:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Heap memory (malloc&#x27;d memory) - freed&lt;&#x2F;li&gt;
&lt;li&gt;File descriptors - closed&lt;&#x2F;li&gt;
&lt;li&gt;Memory mappings - unmapped&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;So for plain &lt;code&gt;malloc()&lt;&#x2F;code&gt; and regular files, you don&#x27;t actually need signal handlers for cleanup. The OS handles it.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Where signal handlers matter:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Shared resources&lt;&#x2F;strong&gt; - shared memory segments (&lt;code&gt;shm_open&lt;&#x2F;code&gt;), semaphores, message queues. These persist beyond process lifetime.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Temp files&lt;&#x2F;strong&gt; - if you want to delete temp files on crash.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;External state&lt;&#x2F;strong&gt; - network connections you want to close gracefully, database transactions to rollback.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Custom cleanup&lt;&#x2F;strong&gt; - resetting terminal modes, unlocking files, etc.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;For my window manager, I use signal handlers to:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Unmap windows gracefully&lt;&#x2F;li&gt;
&lt;li&gt;Restore X11 state&lt;&#x2F;li&gt;
&lt;li&gt;Close the connection to the X server properly&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Regular heap memory? I just let the OS clean it up. It&#x27;s going to do it anyway.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Cleanup at end of main doesn&#x27;t run if you crash&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;atexit()&lt;&#x2F;code&gt; doesn&#x27;t help - it&#x27;s for normal exits only&lt;&#x2F;li&gt;
&lt;li&gt;Signal handlers let you run code on crash&lt;&#x2F;li&gt;
&lt;li&gt;Be careful about async-signal-safety in handlers&lt;&#x2F;li&gt;
&lt;li&gt;For regular malloc&#x27;d memory, the OS cleans up anyway&lt;&#x2F;li&gt;
&lt;li&gt;Signal handlers are useful for shared resources and external state&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The pattern I use in practice:&lt;&#x2F;p&gt;
&lt;pre class=&quot;giallo&quot; style=&quot;color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);&quot;&gt;&lt;code data-lang=&quot;c&quot;&gt;&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;volatile&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#576E65, #83A598);&quot;&gt; sig_atomic_t&lt;&#x2F;span&gt;&lt;span&gt; should_exit &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 0&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; signal_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; sig&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span&gt;    should_exit &lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 1&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;    &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; minimal cleanup for shared resources only&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt; main&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;void&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    signal&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;SIGINT&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; signal_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    signal&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;SIGTERM&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;,&lt;&#x2F;span&gt;&lt;span&gt; signal_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;    &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; main loop checks should_exit&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    while&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;!&lt;&#x2F;span&gt;&lt;span&gt;should_exit&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt; {&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;        &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; work&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;    }&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt;    &#x2F;&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#928374, #7C6F64);font-style: italic;&quot;&gt; full cleanup runs here on graceful exit&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#707943, #A9B665);&quot;&gt;    cleanup&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#9C4641, #EA6962);&quot;&gt;    return&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#8C5967, #D3869B);&quot;&gt; 0&lt;&#x2F;span&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;giallo-l&quot;&gt;&lt;span style=&quot;color: light-dark(#685C52, #9C8B7C);&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;For SIGSEGV&#x2F;SIGABRT, I mostly just let it crash and let the OS clean up. Unless there&#x27;s shared state that needs explicit cleanup, adding a handler for crash signals just complicates things without much benefit.&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
