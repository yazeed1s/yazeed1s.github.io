<!doctype html>
<html lang="en">

<head>
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="How the CPU switches between user and kernel mode, and what triggers those switches." />
<meta
    name="keywords"
    content="yazeed, blog, alharthi, yaz, yazeed1s"
/>
<link rel="canonical" href="https://yazeed1s.github.io/posts/interrupts-traps/" />

<title>Interrupts, Traps, and the Kernel Boundary | Yazeed&#x27;s Blog</title>
<meta property="og:site_name" content="Yazeed&#x27;s Blog" />
<meta property="og:title" content="Interrupts, Traps, and the Kernel Boundary | Yazeed&#x27;s Blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://yazeed1s.github.io/posts/interrupts-traps/" />
<meta property="og:description" content="How the CPU switches between user and kernel mode, and what triggers those switches." />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Interrupts, Traps, and the Kernel Boundary" />
<meta name="twitter:description" content="How the CPU switches between user and kernel mode, and what triggers those switches." />

    <link rel="icon" href="&#x2F;favicon.ico" />
    
    <link rel="stylesheet" href="https://yazeed1s.github.io/font.css" />
    <link rel="stylesheet" href="https://yazeed1s.github.io/css/base.css" />

           
    
    
    

          
    
    
    
    <style>
        :root {
            --nav-basis: 25%;
            --light-bg: #eae6deff;
            --light-text: #1a1410;
            --light-text-muted: #1a1410;
            --light-accent: #9E4440;
            --light-accent-hover: #7A3533;
            --light-code-bg: #e1ded6ff;
            --light-border: #abaaaaff;
            --light-bold: #1a1410;
            --light-italic: #1a1410;
            --light-headers: #1a1410;
            --dark-bg: #303132;
            --dark-text: #bebbb9ff;
            --dark-text-muted: #d5d2cf;
            --dark-accent: #e57665;
            --dark-accent-hover: #888885;
            --dark-code-bg: #282829;
            --dark-border: #524f4c;
            --dark-bold: #d5d2cf;
            --dark-italic: #d5d2cf;
            --dark-headers: #d5d2cf;
        }
    </style>
    <meta name="theme-color" id="tc" />
    <script>
        (function () {
            var m = matchMedia("(prefers-color-scheme:dark)"),
                t = localStorage.theme || (m.matches ? "dark" : "light"),
                h = document.documentElement,
                c = document.getElementById("tc");
            h.className = t;
            function u() {
                c.content = getComputedStyle(h).getPropertyValue("--tc");
            }
            u();
            window.T = function () {
                t = t === "dark" ? "light" : "dark";
                localStorage.theme = t;
                h.className = t;
                u();
            };
        })();
    </script>
    
</head>

<body>
    <a href="#main" class="skip-link">Skip to content</a>
    <svg xmlns="http://www.w3.org/2000/svg" style="display:none"><symbol id="light" viewBox="0 0 32 32"><rect x="15" y="2" width="2" height="5"/><rect x="21.6675" y="6.8536" width="4.958" height="1.9998" transform="translate(1.5191 19.3744) rotate(-45)"/><rect x="25" y="15" width="5" height="2"/><rect x="23.1466" y="21.6675" width="1.9998" height="4.958" transform="translate(-10.0018 24.1465) rotate(-45)"/><rect x="15" y="25" width="2" height="5"/><rect x="5.3745" y="23.1466" width="4.958" height="1.9998" transform="translate(-14.7739 12.6256) rotate(-45)"/><rect x="2" y="15" width="5" height="2"/><rect x="6.8536" y="5.3745" width="1.9998" height="4.958" transform="translate(-3.253 7.8535) rotate(-45)"/><path d="M16,12a4,4,0,1,1-4,4,4.0045,4.0045,0,0,1,4-4m0-2a6,6,0,1,0,6,6,6,6,0,0,0-6-6Z"/></symbol>
<symbol id="asleep" viewBox="0 0 32 32"><path d="M13.5025,5.4136A15.0755,15.0755,0,0,0,25.096,23.6082a11.1134,11.1134,0,0,1-7.9749,3.3893c-.1385,0-.2782.0051-.4178,0A11.0944,11.0944,0,0,1,13.5025,5.4136M14.98,3a1.0024,1.0024,0,0,0-.1746.0156A13.0959,13.0959,0,0,0,16.63,28.9973c.1641.006.3282,0,.4909,0a13.0724,13.0724,0,0,0,10.702-5.5556,1.0094,1.0094,0,0,0-.7833-1.5644A13.08,13.08,0,0,1,15.8892,4.38,1.0149,1.0149,0,0,0,14.98,3Z"/></symbol>
<symbol id="rss" viewBox="0 0 32 32"><path d="M8,18c-3.3,0-6,2.7-6,6s2.7,6,6,6s6-2.7,6-6C14,20.7,11.3,18,8,18z M8,28c-2.2,0-4-1.8-4-4s1.8-4,4-4s4,1.8,4,4C12,26.2,10.2,28,8,28z"/><path d="M30,24h-2C28,13,19,4,8,4V2C20.1,2,30,11.9,30,24z"/><path d="M22,24h-2c0-6.6-5.4-12-12-12v-2C15.7,10,22,16.3,22,24z"/></symbol>
</svg>

    <header id="site-header">
        <div>
            <span class="header-brand"><a href="https://yazeed1s.github.io"><strong><span style="color: var(--accent-hover);">~/</span>Yazeed&#x27;s Blog</strong></a></span>
            <nav>
                <a href="https://yazeed1s.github.io/" >Home</a>
                <a href="https://yazeed1s.github.io/posts/"  class="active" >Posts</a>
                <a href="https://yazeed1s.github.io/projects/" >Projects</a>
                <a href="https://yazeed1s.github.io/tags/" >Tags</a>
                </nav>
            <a href="#" onclick="
                        T();
                        return false;
                    " class="theme" aria-label="Toggle theme" title="Toggle theme">
<svg><use href="#light"/></svg>
<svg><use href="#asleep"/></svg></a>
        </div>
    </header>
    <hr class="site-sep" />
    <main id="main">
<article>
    <header>
        <h1>Interrupts, Traps, and the Kernel Boundary</h1>
        <div class="post-meta">
            <time datetime="2025-03-15">15 Mar 2025</time>
            
            <span>How the CPU switches between user and kernel mode, and what triggers those switches.</span>
             
            <span class="post-tags">
                <span class="post-tags-label">Tags: </span>
                
                <a href="https://yazeed1s.github.io/tags/os">OS</a><span
                    class="tag-comma">,</span> 
                <a href="https://yazeed1s.github.io/tags/cpu">CPU</a><span
                    class="tag-comma">,</span> 
                <a href="https://yazeed1s.github.io/tags/linux">Linux</a>
            </span>
            
        </div>
    </header>
     <p>Your app calls a syscall. A packet arrives on the network card. The timer fires. These all interrupt normal execution, but they're not the same thing. The terminology gets confusing because people use interrupt, trap, and exception loosely.</p>
<h2 id="user-space-vs-kernel-space">user space vs kernel space</h2>
<p>First the basics. Modern CPUs have privilege levels. On x86 these are called rings. Ring 0 is the most privileged (kernel). Ring 3 is least privileged (user applications).</p>
<p>Your application runs in ring 3. It can execute normal instructions, access its own memory, do math. But it cannot:</p>
<ul>
<li>Access hardware directly</li>
<li>Read/write arbitrary memory addresses</li>
<li>Execute privileged instructions (like changing page tables or disabling interrupts)</li>
</ul>
<p>The kernel runs in ring 0. It can do all of those things.</p>
<p>When you call <code>read()</code> to read from a file, your code can't just talk to the disk controller. It has to ask the kernel. The CPU has to switch from ring 3 to ring 0, do the privileged work, then switch back.</p>
<p>This switch is the kernel boundary. Crossing it has a cost. You save registers, change privilege level, potentially flush caches. This is why syscalls aren't free.</p>
<h2 id="interrupts">interrupts</h2>
<p>An interrupt is a signal from hardware that says "stop what you're doing, I need attention."</p>
<p>Examples:</p>
<ul>
<li>Keyboard: "a key was pressed"</li>
<li>Network card: "a packet arrived"</li>
<li>Timer: "your time slice is up"</li>
<li>Disk controller: "that read you asked for is done"</li>
</ul>
<p>Interrupts are asynchronous. They happen whenever the hardware needs attention, regardless of what the CPU is currently doing. You could be in the middle of a for loop and suddenly an interrupt fires.</p>
<p>When an interrupt happens:</p>
<ol>
<li>CPU stops executing current instruction stream</li>
<li>Saves current state (registers, instruction pointer, flags)</li>
<li>Looks up the interrupt handler in the Interrupt Descriptor Table (IDT)</li>
<li>Jumps to that handler (now in ring 0)</li>
<li>Handler does its work</li>
<li>Handler returns, CPU restores state, continues where it left off</li>
</ol>
<p>The key thing: the currently running process doesn't trigger this. It just happens to it.</p>
<h2 id="traps">traps</h2>
<p>A trap is a synchronous exception triggered by the currently running code. It's intentional.</p>
<p>The main example: syscalls. When you call <code>read()</code>, the C library eventually executes a special instruction (<code>syscall</code> on x86-64, <code>int 0x80</code> on older x86) that deliberately triggers a trap.</p>
<pre class="giallo" style="color-scheme: light dark; color: light-dark(#4B4B48, #D4D4C0); background-color: light-dark(#D7D5C3, #212121);"><code data-lang="plain"><span class="giallo-l"><span>User code calls read()</span></span>
<span class="giallo-l"><span>  -&gt; libc wrapper</span></span>
<span class="giallo-l"><span>    -&gt; syscall instruction (trap into kernel)</span></span>
<span class="giallo-l"><span>      -&gt; kernel syscall handler</span></span>
<span class="giallo-l"><span>        -&gt; returns to user space</span></span></code></pre>
<p>The difference from interrupts: you asked for this. The code executing triggered it. It happens at a specific point in your instruction stream, not randomly.</p>
<p>Other traps/exceptions:</p>
<ul>
<li>Page fault — you accessed memory that isn't mapped. Could be a bug, or could be demand paging doing its job.</li>
<li>Division by zero — arithmetic error</li>
<li>Invalid opcode — tried to execute garbage</li>
<li>Breakpoint — debugger trap (int 3)</li>
</ul>
<p>Some of these are errors (division by zero kills your process). Some are handled and execution continues (page fault loads the page, then your load instruction retries).</p>
<h2 id="the-naming-confusion">the naming confusion</h2>
<p>Different sources use these terms differently. Here's how I think about it:</p>
<ul>
<li><strong>Interrupt</strong> — external, async, from hardware</li>
<li><strong>Trap</strong> — internal, sync, intentional (syscalls)</li>
<li><strong>Exception</strong> — internal, sync, usually an error (page fault, div by zero)</li>
<li><strong>Fault</strong> — exception that can be corrected (page fault) — instruction retries</li>
<li><strong>Abort</strong> — unrecoverable error</li>
</ul>
<p>Some people use "exception" as the umbrella term for everything. Some use "interrupt" for everything. The Intel manual has its own definitions. It's messy.</p>
<p>What matters: understand whether the trigger is external (hardware) or internal (executing code), and whether it's expected (syscall) or unexpected (error).</p>
<h2 id="the-interrupt-descriptor-table">the interrupt descriptor table</h2>
<p>The CPU needs to know where to jump for each interrupt/exception. This is stored in the IDT, a table in memory. The kernel sets this up at boot.</p>
<p>Each entry has:</p>
<ul>
<li>Handler address</li>
<li>What privilege level can trigger it</li>
<li>Gate type (interrupt gate, trap gate)</li>
</ul>
<p>For hardware interrupts, the entries point to kernel interrupt handlers. For the syscall trap, it points to the syscall entry point.</p>
<p>When an interrupt fires, the CPU:</p>
<ol>
<li>Uses the interrupt number as an index into IDT</li>
<li>Checks privilege</li>
<li>Switches to ring 0 if needed</li>
<li>Jumps to the handler address</li>
</ol>
<h2 id="hardware-interrupts-in-more-detail">hardware interrupts in more detail</h2>
<p>When a device needs attention, it signals an interrupt request (IRQ). On modern systems this goes through an interrupt controller (APIC).</p>
<p>The kernel has to:</p>
<ol>
<li>Acknowledge the interrupt</li>
<li>Figure out which device caused it</li>
<li>Call the right driver's handler</li>
<li>Tell the interrupt controller we're done</li>
</ol>
<p>Handling needs to be fast because interrupts are disabled (or that IRQ is masked) while you're in the handler. If you take too long, you miss other interrupts.</p>
<p>Linux splits this into top half and bottom half:</p>
<ul>
<li><strong>Top half</strong>: runs in interrupt context, does minimum work, schedules bottom half</li>
<li><strong>Bottom half</strong>: runs later with interrupts enabled, does the real work (softirqs, tasklets, workqueues)</li>
</ul>
<p>For example, network card interrupt:</p>
<ul>
<li>Top half: grab the packet from hardware, queue it, schedule bottom half</li>
<li>Bottom half: process the packet up the network stack</li>
</ul>
<h2 id="syscall-cost">syscall cost</h2>
<p>Crossing the kernel boundary isn't free. You pay for:</p>
<ul>
<li>Saving/restoring registers</li>
<li>Switching stacks (user stack -&gt; kernel stack)</li>
<li>TLB and cache effects</li>
<li>Spectre mitigations on modern kernels (KPTI, retpolines)</li>
</ul>
<p>On a modern system, a syscall might take a few hundred nanoseconds. Doesn't sound like much, but if you're doing thousands per second, it adds up.</p>
<p>This is why people use:</p>
<ul>
<li>Batching (fewer syscalls, more work per call)</li>
<li>io_uring (submit many I/O requests with one syscall)</li>
<li>mmap (access files without read() syscalls)</li>
</ul>
<h2 id="notes">notes</h2>
<ul>
<li>On x86-64, <code>syscall</code>/<code>sysret</code> are faster than the old <code>int 0x80</code> method</li>
<li><code>/proc/interrupts</code> shows interrupt counts per CPU</li>
<li><code>perf stat</code> can count context switches and syscalls</li>
<li>NMI (Non-Maskable Interrupt) can't be disabled, used for profiling and panic</li>
<li>The timer interrupt is what makes preemptive multitasking work</li>
</ul>
  
</article>
</main>
    <hr class="site-sep bottom-sep" />
    <footer class="s">
        
    </footer>
    

    <script>
        document.querySelectorAll("article img[srcset]").forEach((i) => {
            if (i.closest("a")) return;
            i.style.cursor = "pointer";
            i.onclick = () => {
                let d = document.createElement("div"),
                    s = i.srcset.split(",").pop().trim().split(" ")[0];
                d.className = "lb";
                d.innerHTML = '<img src="' + s + '">';
                document.body.style.overflow = "hidden";
                d.onclick = () => {
                    d.remove();
                    document.body.style.overflow = "";
                };
                document.body.appendChild(d);
            };
        });
    </script>
    
<button id="scroll-to-top" aria-label="Scroll to top" title="Scroll to top">↑</button>
<script>
    (function() {
        var btn = document.getElementById("scroll-to-top");
        if (btn) {
            window.addEventListener("scroll", function() {
                if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
                    btn.classList.add("show");
                } else {
                    btn.classList.remove("show");
                }
            });
            btn.addEventListener("click", function() {
                window.scrollTo({top: 0, behavior: 'smooth'});
            });
        }
    })();
</script>
</body>

</html>