<!doctype html>
<html lang="en">

<head>
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="How RDMA bypasses the kernel on the data path, letting NICs DMA straight between user buffers." />
<meta
    name="keywords"
    content="yazeed, blog, alharthi, yaz, yazeed1s"
/>
<link rel="canonical" href="https://yazeed1s.github.io/posts/rdma/" />

<title>RDMA: Bypassing the Kernel for Network I&#x2F;O | Yazeed&#x27;s Blog</title>
<meta property="og:site_name" content="Yazeed&#x27;s Blog" />
<meta property="og:title" content="RDMA: Bypassing the Kernel for Network I&#x2F;O | Yazeed&#x27;s Blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://yazeed1s.github.io/posts/rdma/" />
<meta property="og:description" content="How RDMA bypasses the kernel on the data path, letting NICs DMA straight between user buffers." />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="RDMA: Bypassing the Kernel for Network I&#x2F;O" />
<meta name="twitter:description" content="How RDMA bypasses the kernel on the data path, letting NICs DMA straight between user buffers." />

    <link rel="icon" href="&#x2F;favicon.ico" />
    
    <link rel="stylesheet" href="https://yazeed1s.github.io/font.css" />
    <link rel="stylesheet" href="https://yazeed1s.github.io/css/base.css" />

                  
    <style>
        :root {
            --nav-basis: 25

            %;

            --light-bg: #eae6deff

            ;

            --light-text: #1a1410

            ;

            --light-text-muted: #1a1410

            ;

            --light-accent: #9E4440

            ;

            --light-accent-hover: #7A3533

            ;

            --light-code-bg: #e1ded6ff

            ;

            --light-border: #abaaaaff

            ;

            --dark-bg: #303132

            ;

            --dark-text: #bebbb9ff

            ;

            --dark-text-muted: #d5d2cf

            ;

            --dark-accent: #e57665

            ;

            --dark-accent-hover: #888885

            ;

            --dark-code-bg: #282829

            ;

            --dark-border: #524f4c

            ;
        }
    </style>
    <meta name="theme-color" id="tc" />
    <script>
        (function () {
            var m = matchMedia("(prefers-color-scheme:dark)"),
                t = localStorage.theme || (m.matches ? "dark" : "light"),
                h = document.documentElement,
                c = document.getElementById("tc");
            h.className = t;
            function u() {
                c.content = getComputedStyle(h).getPropertyValue("--tc");
            }
            u();
            window.T = function () {
                t = t === "dark" ? "light" : "dark";
                localStorage.theme = t;
                h.className = t;
                u();
            };
        })();
    </script>
    
</head>

<body>
    <a href="#main" class="skip-link">Skip to content</a>
    <svg xmlns="http://www.w3.org/2000/svg" style="display:none"><symbol id="light" viewBox="0 0 32 32"><rect x="15" y="2" width="2" height="5"/><rect x="21.6675" y="6.8536" width="4.958" height="1.9998" transform="translate(1.5191 19.3744) rotate(-45)"/><rect x="25" y="15" width="5" height="2"/><rect x="23.1466" y="21.6675" width="1.9998" height="4.958" transform="translate(-10.0018 24.1465) rotate(-45)"/><rect x="15" y="25" width="2" height="5"/><rect x="5.3745" y="23.1466" width="4.958" height="1.9998" transform="translate(-14.7739 12.6256) rotate(-45)"/><rect x="2" y="15" width="5" height="2"/><rect x="6.8536" y="5.3745" width="1.9998" height="4.958" transform="translate(-3.253 7.8535) rotate(-45)"/><path d="M16,12a4,4,0,1,1-4,4,4.0045,4.0045,0,0,1,4-4m0-2a6,6,0,1,0,6,6,6,6,0,0,0-6-6Z"/></symbol>
<symbol id="asleep" viewBox="0 0 32 32"><path d="M13.5025,5.4136A15.0755,15.0755,0,0,0,25.096,23.6082a11.1134,11.1134,0,0,1-7.9749,3.3893c-.1385,0-.2782.0051-.4178,0A11.0944,11.0944,0,0,1,13.5025,5.4136M14.98,3a1.0024,1.0024,0,0,0-.1746.0156A13.0959,13.0959,0,0,0,16.63,28.9973c.1641.006.3282,0,.4909,0a13.0724,13.0724,0,0,0,10.702-5.5556,1.0094,1.0094,0,0,0-.7833-1.5644A13.08,13.08,0,0,1,15.8892,4.38,1.0149,1.0149,0,0,0,14.98,3Z"/></symbol>
<symbol id="rss" viewBox="0 0 32 32"><path d="M8,18c-3.3,0-6,2.7-6,6s2.7,6,6,6s6-2.7,6-6C14,20.7,11.3,18,8,18z M8,28c-2.2,0-4-1.8-4-4s1.8-4,4-4s4,1.8,4,4C12,26.2,10.2,28,8,28z"/><path d="M30,24h-2C28,13,19,4,8,4V2C20.1,2,30,11.9,30,24z"/><path d="M22,24h-2c0-6.6-5.4-12-12-12v-2C15.7,10,22,16.3,22,24z"/></symbol>
</svg>

    <header id="site-header">
        <div>
            <span class="header-brand"><a href="https://yazeed1s.github.io"><strong><span style="color: var(--accent-hover);">~/</span>Yazeed&#x27;s Blog</strong></a></span>
            <nav>
                <a href="https://yazeed1s.github.io/" >Home</a>
                <a href="https://yazeed1s.github.io/posts/"  class="active" >Posts</a>
                <a href="https://yazeed1s.github.io/projects/" >Projects</a>
                <a href="https://yazeed1s.github.io/tags/" >Tags</a>
                </nav>
            <a href="#" onclick="
                        T();
                        return false;
                    " class="theme" aria-label="Toggle theme" title="Toggle theme">
<svg><use href="#light"/></svg>
<svg><use href="#asleep"/></svg></a>
        </div>
    </header>
    <hr class="site-sep" />
    <main id="main">
<article>
    <header>
        <h1>RDMA: Bypassing the Kernel for Network I&#x2F;O</h1>
        <div class="post-meta">
            <time datetime="2025-12-28">28 Dec 2025</time>
            
            <span>How RDMA bypasses the kernel on the data path, letting NICs DMA straight between user buffers.</span>
             
            <span class="post-tags">
                <span class="post-tags-label">Tags: </span>
                
                <a href="https://yazeed1s.github.io/tags/rdma">RDMA</a><span
                    class="tag-comma">,</span> 
                <a href="https://yazeed1s.github.io/tags/networking">Networking</a><span
                    class="tag-comma">,</span> 
                <a href="https://yazeed1s.github.io/tags/kernel-bypass">Kernel Bypass</a><span
                    class="tag-comma">,</span> 
                <a href="https://yazeed1s.github.io/tags/systems-programming">Systems Programming</a>
            </span>
            
        </div>
    </header>
     <hr />
<p>I've been reading about memory disaggregation and kept running into RDMA as the enabling technology. The pitch is simple: what if your application could read and write memory on a remote machine without dragging the remote CPU into the loop?</p>
<p>The core concept is kernel bypass. In traditional TCP, every packet goes through the kernel's network stack. Data gets copied (or at least touched) as it crosses user/kernel boundaries, checksums happen, packets get queued, interrupts fire. The CPU is in the middle of basically everything.</p>
<p>RDMA flips this. The network card (called an RNIC) reads directly from your application's memory buffer and sends it over the wire. The remote RNIC DMA-writes directly into the destination application's buffer.</p>
<p>No kernel on the data path, no socket buffers, and (for one-sided ops) no remote syscall/interrupt just to move bytes. (You still pay CPU to post work and handle completions, but you stop burning cycles on the kernel stack and copies.)</p>
<p>This is why systems like Infiniswap and modern distributed databases obsess over RDMA. Often single-digit microsecond latencies instead of tens or hundreds.</p>
<p>The difference is clear when you visualize the stack:</p>
<p><img src="/images/rdma.png" alt="TCP vs RDMA" /></p>
<pre class="giallo" style="color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);"><code data-lang="plain"><span class="giallo-l"><span>                   TCP/IP                                      RDMA</span></span>
<span class="giallo-l"></span>
<span class="giallo-l"><span>+-------------------+  +-------------------+     +-------------------+  +-------------------+</span></span>
<span class="giallo-l"><span>|      SERVER       |  |      SERVER       |     |      SERVER       |  |      SERVER       |</span></span>
<span class="giallo-l"><span>|                   |  |                   |     |                   |  |                   |</span></span>
<span class="giallo-l"><span>|   +-----------+   |  |   +-----------+   |     |   +-----------+   |  |   +-----------+   |</span></span>
<span class="giallo-l"><span>|   |    App    |   |  |   |    App    |   |     |   |    App    |   |  |   |    App    |   |</span></span>
<span class="giallo-l"><span>|   +-----+-----+   |  |   +-----+-----+   |     |   +-----+-----+   |  |   +-----+-----+   |</span></span>
<span class="giallo-l"><span>|         |         |  |         |         |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|         v         |  |         v         |     |         v         |  |         v         |</span></span>
<span class="giallo-l"><span>|   +-----------+   |  |   +-----------+   |     |   +-----------+   |  |   +-----------+   |</span></span>
<span class="giallo-l"><span>|   |  Buffer   |   |  |   |  Buffer   |   |     |   |  Buffer   |   |  |   |  Buffer   |   |</span></span>
<span class="giallo-l"><span>|   +-----+-----+   |  |   +-----+-----+   |     |   +-----+-----+   |  |   +-----+-----+   |</span></span>
<span class="giallo-l"><span>|         |         |  |         |         |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|         v         |  |         v         |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|   +-----------+   |  |   +-----------+   |     |   (kernel bypass) |  |   (kernel bypass) |</span></span>
<span class="giallo-l"><span>|   |  Sockets  |   |  |   |  Sockets  |   |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|   +-----+-----+   |  |   +-----+-----+   |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|         |         |  |         |         |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|         v         |  |         v         |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|   +-----------+   |  |   +-----------+   |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|   | Transport |   |  |   | Transport |   |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|   +-----+-----+   |  |   +-----+-----+   |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|         |         |  |         |         |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|         v         |  |         v         |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|   +-----------+   |  |   +-----------+   |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|   | NIC Drvr  |   |  |   | NIC Drvr  |   |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|   +-----+-----+   |  |   +-----+-----+   |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>|         |         |  |         |         |     |         |         |  |         |         |</span></span>
<span class="giallo-l"><span>+---------+---------+  +---------+---------+     +---------+---------+  +---------+---------+</span></span>
<span class="giallo-l"><span>          |                      |                         |                      |</span></span>
<span class="giallo-l"><span>          v                      v                         v                      v</span></span>
<span class="giallo-l"><span>       [NIC]&lt;-----------------&gt;[NIC]                    [RNIC]&lt;----------------&gt;[RNIC]</span></span></code></pre>
<hr />
<h2 id="the-hardware">the hardware</h2>
<p>You need an RNIC (RDMA Network Interface Card). This isn't your regular NIC. The RNIC implements RDMA protocols in hardware—it knows how to access memory regions, validate permissions, and move data without running the kernel network stack on every packet.</p>
<p>Two common protocol families:</p>
<p><strong>InfiniBand (IB):</strong> The original RDMA technology. Requires special switches and cabling. Common in HPC clusters and supercomputers. Latencies under 1μs.</p>
<p><strong>RoCE (RDMA over Converged Ethernet):</strong> Runs over Ethernet. Easier to deploy if you already have Ethernet infrastructure, but in practice you usually end up treating the fabric as "almost lossless" (PFC/ECN/DCB tuning) or performance gets ugly under loss/congestion. Slightly higher latency than InfiniBand, but close enough for most use cases.</p>
<p>There's also iWARP (RDMA over TCP). It avoids the whole "make Ethernet lossless" dance, but it's less common in modern deployments and often doesn't match RoCE/IB latency.</p>
<hr />
<h2 id="the-programming-model">the programming model</h2>
<p>RDMA exposes a different mental model than sockets. Instead of <code>send()</code> and <code>recv()</code>, you work with queues and memory regions. The main abstractions from <code>libibverbs</code> (the userspace library from <a rel="external" href="https://github.com/linux-rdma/rdma-core">rdma-core</a>):</p>
<p><strong>Queue Pair (QP):</strong> Your connection to the hardware. A QP has two queues (a send queue and a receive queue). You post work requests to these queues, and the RNIC processes them asynchronously.</p>
<pre class="giallo" style="color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);"><code data-lang="c"><span class="giallo-l"><span style="color: light-dark(#9C4641, #EA6962);">struct</span><span> ibv_qp </span><span style="color: light-dark(#9C4641, #EA6962);">*</span><span style="color: light-dark(#707943, #A9B665);">ibv_create_qp</span><span style="color: light-dark(#685C52, #9C8B7C);">(</span><span style="color: light-dark(#9C4641, #EA6962);">struct</span><span> ibv_pd </span><span style="color: light-dark(#9C4641, #EA6962);">*</span><span>pd</span><span style="color: light-dark(#685C52, #9C8B7C);">,</span></span>
<span class="giallo-l"><span style="color: light-dark(#9C4641, #EA6962);">                             struct</span><span> ibv_qp_init_attr </span><span style="color: light-dark(#9C4641, #EA6962);">*</span><span>qp_init_attr</span><span style="color: light-dark(#685C52, #9C8B7C);">)</span><span style="color: light-dark(#685C52, #9C8B7C);">;</span></span></code></pre>
<p>Creating a QP isn't enough. Fresh QPs start in a <code>RESET</code> state. You have to walk them through a state machine: <code>RESET</code> -&gt; <code>INIT</code> -&gt; <code>RTR</code> (ready to receive) -&gt; <code>RTS</code> (ready to send). Only then can data actually flow. This trips up everyone the first time.</p>
<p><strong>Completion Queue (CQ):</strong> How you know an operation finished. When the RNIC completes a work request, it posts a completion entry to the CQ. You poll the CQ or wait for an interrupt.</p>
<pre class="giallo" style="color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);"><code data-lang="c"><span class="giallo-l"><span style="color: light-dark(#9C4641, #EA6962);">struct</span><span> ibv_cq </span><span style="color: light-dark(#9C4641, #EA6962);">*</span><span style="color: light-dark(#707943, #A9B665);">ibv_create_cq</span><span style="color: light-dark(#685C52, #9C8B7C);">(</span><span style="color: light-dark(#9C4641, #EA6962);">struct</span><span> ibv_context </span><span style="color: light-dark(#9C4641, #EA6962);">*</span><span>context</span><span style="color: light-dark(#685C52, #9C8B7C);">,</span><span style="color: light-dark(#9C4641, #EA6962);"> int</span><span> cqe</span><span style="color: light-dark(#685C52, #9C8B7C);">,</span></span>
<span class="giallo-l"><span style="color: light-dark(#9C4641, #EA6962);">                             void</span><span style="color: light-dark(#9C4641, #EA6962);"> *</span><span>cq_context</span><span style="color: light-dark(#685C52, #9C8B7C);">,</span></span>
<span class="giallo-l"><span style="color: light-dark(#9C4641, #EA6962);">                             struct</span><span> ibv_comp_channel </span><span style="color: light-dark(#9C4641, #EA6962);">*</span><span>channel</span><span style="color: light-dark(#685C52, #9C8B7C);">,</span></span>
<span class="giallo-l"><span style="color: light-dark(#9C4641, #EA6962);">                             int</span><span> comp_vector</span><span style="color: light-dark(#685C52, #9C8B7C);">)</span><span style="color: light-dark(#685C52, #9C8B7C);">;</span></span></code></pre>
<p>Two modes for processing completions:</p>
<ul>
<li><strong>Polling:</strong> Call <code>ibv_poll_cq</code> in a loop. Lowest latency, highest throughput, burns CPU.</li>
<li><strong>Interrupt-based:</strong> Use <code>ibv_req_notify_cq</code> to arm the CQ for events. Lower CPU usage, higher latency.</li>
</ul>
<p>A single CQ can serve multiple QPs. This is useful for consolidating completion processing.</p>
<p><strong>Memory Region (MR):</strong> Before the RNIC can touch your memory, you must register it. Registration does two things: pins the memory so it can't be swapped to disk, and gives you keys.</p>
<pre class="giallo" style="color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);"><code data-lang="c"><span class="giallo-l"><span style="color: light-dark(#9C4641, #EA6962);">struct</span><span> ibv_mr </span><span style="color: light-dark(#9C4641, #EA6962);">*</span><span style="color: light-dark(#707943, #A9B665);">ibv_reg_mr</span><span style="color: light-dark(#685C52, #9C8B7C);">(</span><span style="color: light-dark(#9C4641, #EA6962);">struct</span><span> ibv_pd </span><span style="color: light-dark(#9C4641, #EA6962);">*</span><span>pd</span><span style="color: light-dark(#685C52, #9C8B7C);">,</span><span style="color: light-dark(#9C4641, #EA6962);"> void</span><span style="color: light-dark(#9C4641, #EA6962);"> *</span><span>addr</span><span style="color: light-dark(#685C52, #9C8B7C);">,</span></span>
<span class="giallo-l"><span style="color: light-dark(#9C4641, #EA6962);">                          size_t</span><span> length</span><span style="color: light-dark(#685C52, #9C8B7C);">,</span><span style="color: light-dark(#9C4641, #EA6962);"> int</span><span> access</span><span style="color: light-dark(#685C52, #9C8B7C);">)</span><span style="color: light-dark(#685C52, #9C8B7C);">;</span></span></code></pre>
<p>The <code>access</code> flags matter. <code>IBV_ACCESS_LOCAL_WRITE</code> lets the RNIC write into this MR (e.g., receives). <code>IBV_ACCESS_REMOTE_READ</code> and <code>IBV_ACCESS_REMOTE_WRITE</code> let remote machines access it directly. The registration returns an <code>lkey</code> (used by the local RNIC to validate local work requests) and an <code>rkey</code> (presented by remote peers). You share the rkey with the other side.</p>
<p><strong>Protection Domain (PD):</strong> A security boundary. QPs and MRs belong to a PD. The RNIC checks that any operation matches—you can't use an MR with a QP from a different PD. This replaces the safety checks we lost by bypassing the kernel.</p>
<pre class="giallo" style="color-scheme: light dark; color: light-dark(#3C3836, #D3C6AA); background-color: light-dark(#151515, #202020);"><code data-lang="c"><span class="giallo-l"><span style="color: light-dark(#9C4641, #EA6962);">struct</span><span> ibv_pd </span><span style="color: light-dark(#9C4641, #EA6962);">*</span><span style="color: light-dark(#707943, #A9B665);">ibv_alloc_pd</span><span style="color: light-dark(#685C52, #9C8B7C);">(</span><span style="color: light-dark(#9C4641, #EA6962);">struct</span><span> ibv_context </span><span style="color: light-dark(#9C4641, #EA6962);">*</span><span>context</span><span style="color: light-dark(#685C52, #9C8B7C);">)</span><span style="color: light-dark(#685C52, #9C8B7C);">;</span></span></code></pre>
<hr />
<h2 id="one-sided-vs-two-sided">one-sided vs two-sided</h2>
<p>RDMA supports both:</p>
<p><strong>Two-sided (send/receive):</strong> Traditional messaging. One side posts a send, the other posts a receive. Both CPUs are aware of the transfer. Simpler to reason about, similar to sockets.</p>
<p><strong>One-sided (RDMA read/write):</strong> The magic. RDMA_WRITE shoves data into remote memory without the remote CPU knowing. RDMA_READ pulls data out. The remote application keeps running, oblivious. This is how you get no remote CPU involvement in the data movement.</p>
<p>One-sided operations need the remote memory region's address and rkey. You typically exchange these out-of-band during connection setup.</p>
<p>The gotcha: "oblivious" doesn't mean "safe." You're writing memory via DMA, not calling a function on the remote core. You still need a synchronization protocol (and careful ordering) so the remote side knows when it can read that memory.</p>
<hr />
<h2 id="who-validates-operations">who validates operations?</h2>
<p>If the kernel isn't inspecting every packet, what stops bad memory accesses?</p>
<p>The RNIC hardware takes over. The setup/transfer split:</p>
<p><strong>Setup (kernel involved):</strong> When you call <code>ibv_reg_mr</code>, the kernel tells the hardware exactly which addresses are valid and what permissions apply. The hardware stores this.</p>
<p><strong>Transfer (kernel asleep):</strong> During data movement, the RNIC checks every operation against those rules. If you mess up local registration/keys/permissions, you'll see local errors like <code>IBV_WC_LOC_PROT_ERR</code>. If the remote rejects the request (bad rkey/permissions or invalid remote address), you'll see a remote error like <code>IBV_WC_REM_ACCESS_ERR</code> or <code>IBV_WC_REM_INV_REQ_ERR</code>.</p>
<p>The hardware also handles corruption. It checks CRCs, drops bad packets, requests retries. You get reliable delivery without TCP's overhead.</p>
<hr />
<h2 id="where-rdma-wins">where rdma wins</h2>
<ul>
<li><strong>Latency-critical paths:</strong> Sub-microsecond matters when you're doing millions of small operations per second.</li>
<li><strong>High-throughput bulk transfers:</strong> The CPU isn't the bottleneck when the RNIC handles everything.</li>
<li><strong>Memory disaggregation:</strong> Systems like Infiniswap swap pages to remote memory over RDMA. Works because you're paying microseconds over the fabric instead of milliseconds to disk.</li>
<li><strong>Distributed databases and KV stores:</strong> RAMCloud, FaRM, and others build on RDMA for fast replication and reads.</li>
</ul>
<h2 id="where-it-hurts">where it hurts</h2>
<ul>
<li><strong>Programming complexity:</strong> The queue/completion model is harder than sockets. State machines, pinned memory, keys—there's a lot to get right.</li>
<li><strong>Debugging is painful:</strong> Problems manifest as cryptic completion status codes. No tcpdump. Tools are improving but still rough.</li>
<li><strong>Hardware cost:</strong> RNICs and InfiniBand switches aren't cheap. RoCE helps if you already have decent Ethernet.</li>
<li><strong>Not worth it for large, infrequent transfers:</strong> If you're sending a few big blobs over slow intervals, TCP's overhead is negligible and the simplicity wins.</li>
</ul>
<hr />
<h2 id="notes">notes</h2>
<ul>
<li>Paper: <a rel="external" href="https://www.usenix.org/system/files/nsdi22-paper-reda_1.pdf">RDMA is Turing complete, we just did not know it yet!</a></li>
<li>RDMA's "zero-copy" means the RNIC reads directly from your user-space buffer. No kernel buffer, no extra copy. The CPU does zero memory-copy work for the transfer itself.</li>
<li>Memory registration (<code>ibv_reg_mr</code>) pins pages via the kernel/driver so the RNIC can DMA safely. Large registrations can hit <code>ulimit -l</code> / <code>RLIMIT_MEMLOCK</code> limits.</li>
<li>QP state transitions are required because each state enables different capabilities and checks. You can't skip steps.</li>
<li>Scatter/gather elements (SGEs) let you describe non-contiguous memory in a single work request. They always point to local memory.</li>
<li>One application can have multiple QPs and CQs. CQs aren't 1:1 with queues—flexibility for different polling strategies.</li>
<li>Atomic operations (compare-and-swap, fetch-and-add) are also available for lock-free distributed algorithms.</li>
<li>libibverbs man pages: <a rel="external" href="https://github.com/linux-rdma/rdma-core/blob/master/libibverbs/man/ibv_create_qp.3">ibv_create_qp</a>, <a rel="external" href="https://github.com/linux-rdma/rdma-core/blob/master/libibverbs/man/ibv_reg_mr.3">ibv_reg_mr</a>, <a rel="external" href="https://github.com/linux-rdma/rdma-core/blob/master/libibverbs/man/ibv_create_cq.3">ibv_create_cq</a></li>
</ul>
  
</article>
</main>
    <hr class="site-sep bottom-sep" />
    <footer class="s">
        
    </footer>
    
    <script>
        document.querySelectorAll("article img[srcset]").forEach((i) => {
            if (i.closest("a")) return;
            i.style.cursor = "pointer";
            i.onclick = () => {
                let d = document.createElement("div"),
                    s = i.srcset.split(",").pop().trim().split(" ")[0];
                d.className = "lb";
                d.innerHTML = '<img src="' + s + '">';
                document.body.style.overflow = "hidden";
                d.onclick = () => {
                    d.remove();
                    document.body.style.overflow = "";
                };
                document.body.appendChild(d);
            };
        });
    </script>
    </body>

</html>