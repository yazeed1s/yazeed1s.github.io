<!doctype html>
<html lang="en">

<head>
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="How modern data centers separate memory pools from compute nodes." />
<meta
    name="keywords"
    content="yazeed, blog, alharthi, yaz, yazeed1s"
/>
<link rel="canonical" href="https://yazeed1s.github.io/posts/memory-disaggregation/" />

<title>Memory Disaggregation: Decoupling Memory from Compute | Yazeed&#x27;s Blog</title>
<meta property="og:site_name" content="Yazeed&#x27;s Blog" />
<meta property="og:title" content="Memory Disaggregation: Decoupling Memory from Compute | Yazeed&#x27;s Blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://yazeed1s.github.io/posts/memory-disaggregation/" />
<meta property="og:description" content="How modern data centers separate memory pools from compute nodes." />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Memory Disaggregation: Decoupling Memory from Compute" />
<meta name="twitter:description" content="How modern data centers separate memory pools from compute nodes." />

    <link rel="icon" href="&#x2F;favicon.ico" />
    
    <link rel="stylesheet" href="https://yazeed1s.github.io/font.css" />
    <link rel="stylesheet" href="https://yazeed1s.github.io/css/base.css" />

                  
    <style>
        :root {
            --nav-basis: 25

            %;

            --light-bg: #eae6deff

            ;

            --light-text: #1a1410

            ;

            --light-text-muted: #1a1410

            ;

            --light-accent: #9E4440

            ;

            --light-accent-hover: #7A3533

            ;

            --light-code-bg: #e1ded6ff

            ;

            --light-border: #abaaaaff

            ;

            --dark-bg: #303132

            ;

            --dark-text: #bebbb9ff

            ;

            --dark-text-muted: #d5d2cf

            ;

            --dark-accent: #e57665

            ;

            --dark-accent-hover: #888885

            ;

            --dark-code-bg: #282829

            ;

            --dark-border: #524f4c

            ;
        }
    </style>
    <meta name="theme-color" id="tc" />
    <script>
        (function () {
            var m = matchMedia("(prefers-color-scheme:dark)"),
                t = localStorage.theme || (m.matches ? "dark" : "light"),
                h = document.documentElement,
                c = document.getElementById("tc");
            h.className = t;
            function u() {
                c.content = getComputedStyle(h).getPropertyValue("--tc");
            }
            u();
            window.T = function () {
                t = t === "dark" ? "light" : "dark";
                localStorage.theme = t;
                h.className = t;
                u();
            };
        })();
    </script>
    
</head>

<body>
    <a href="#main" class="skip-link">Skip to content</a>
    <svg xmlns="http://www.w3.org/2000/svg" style="display:none"><symbol id="light" viewBox="0 0 32 32"><rect x="15" y="2" width="2" height="5"/><rect x="21.6675" y="6.8536" width="4.958" height="1.9998" transform="translate(1.5191 19.3744) rotate(-45)"/><rect x="25" y="15" width="5" height="2"/><rect x="23.1466" y="21.6675" width="1.9998" height="4.958" transform="translate(-10.0018 24.1465) rotate(-45)"/><rect x="15" y="25" width="2" height="5"/><rect x="5.3745" y="23.1466" width="4.958" height="1.9998" transform="translate(-14.7739 12.6256) rotate(-45)"/><rect x="2" y="15" width="5" height="2"/><rect x="6.8536" y="5.3745" width="1.9998" height="4.958" transform="translate(-3.253 7.8535) rotate(-45)"/><path d="M16,12a4,4,0,1,1-4,4,4.0045,4.0045,0,0,1,4-4m0-2a6,6,0,1,0,6,6,6,6,0,0,0-6-6Z"/></symbol>
<symbol id="asleep" viewBox="0 0 32 32"><path d="M13.5025,5.4136A15.0755,15.0755,0,0,0,25.096,23.6082a11.1134,11.1134,0,0,1-7.9749,3.3893c-.1385,0-.2782.0051-.4178,0A11.0944,11.0944,0,0,1,13.5025,5.4136M14.98,3a1.0024,1.0024,0,0,0-.1746.0156A13.0959,13.0959,0,0,0,16.63,28.9973c.1641.006.3282,0,.4909,0a13.0724,13.0724,0,0,0,10.702-5.5556,1.0094,1.0094,0,0,0-.7833-1.5644A13.08,13.08,0,0,1,15.8892,4.38,1.0149,1.0149,0,0,0,14.98,3Z"/></symbol>
<symbol id="rss" viewBox="0 0 32 32"><path d="M8,18c-3.3,0-6,2.7-6,6s2.7,6,6,6s6-2.7,6-6C14,20.7,11.3,18,8,18z M8,28c-2.2,0-4-1.8-4-4s1.8-4,4-4s4,1.8,4,4C12,26.2,10.2,28,8,28z"/><path d="M30,24h-2C28,13,19,4,8,4V2C20.1,2,30,11.9,30,24z"/><path d="M22,24h-2c0-6.6-5.4-12-12-12v-2C15.7,10,22,16.3,22,24z"/></symbol>
</svg>

    <header id="site-header">
        <div>
            <span class="header-brand"><a href="https://yazeed1s.github.io"><strong><span style="color: var(--accent-hover);">~/</span>Yazeed&#x27;s Blog</strong></a></span>
            <nav>
                <a href="https://yazeed1s.github.io/" >Home</a>
                <a href="https://yazeed1s.github.io/posts/"  class="active" >Posts</a>
                <a href="https://yazeed1s.github.io/projects/" >Projects</a>
                <a href="https://yazeed1s.github.io/tags/" >Tags</a>
                </nav>
            <a href="#" onclick="
                        T();
                        return false;
                    " class="theme" aria-label="Toggle theme" title="Toggle theme">
<svg><use href="#light"/></svg>
<svg><use href="#asleep"/></svg></a>
        </div>
    </header>
    <hr class="site-sep" />
    <main id="main">
<article>
    <header>
        <h1>Memory Disaggregation: Decoupling Memory from Compute</h1>
        <div class="post-meta">
            <time datetime="2026-01-05">05 Jan 2026</time>
            
            <span>How modern data centers separate memory pools from compute nodes.</span>
             
            <span class="post-tags">
                <span class="post-tags-label">Tags: </span>
                
                <a href="https://yazeed1s.github.io/tags/memory">Memory</a><span
                    class="tag-comma">,</span> 
                <a href="https://yazeed1s.github.io/tags/distributed-systems">Distributed Systems</a><span
                    class="tag-comma">,</span> 
                <a href="https://yazeed1s.github.io/tags/data-centers">Data Centers</a><span
                    class="tag-comma">,</span> 
                <a href="https://yazeed1s.github.io/tags/hardware">Hardware</a>
            </span>
            
        </div>
    </header>
     <hr />
<p>This paper from VMware Research caught my attention because it asks a question I'd been circling around: why hasn't memory disaggregation happened already?</p>
<p>The idea has been around since the 90s. Intel pushed Rack Scale Architecture in 2013. But it never took off. The authors argue that two things finally align now: a burning economic problem and feasible technology to solve it.</p>
<hr />
<h2 id="the-core-idea">the core idea</h2>
<p>Traditional servers bundle everything (CPU, memory, storage) into one box. If you need more RAM, you buy a bigger box or add DIMMs (if you haven't hit the motherboard limit). If you don't use all your RAM, it sits idle.</p>
<p>Memory disaggregation pulls memory out into separate pools that multiple servers can access. Think of it like the shift from local storage to SAN/NAS, but for memory, or better yet, like a GPU rack but for memory.</p>
<p>This gives you two things:</p>
<p><strong>Capacity expansion.</strong> A server can use more memory than it physically contains by accessing the pool. Similar to Infiniswap, but with hardware support instead of software paging.</p>
<p><strong>Data sharing.</strong> In the limit, pool memory can be mapped into multiple hosts so they can load/store into the same bytes without explicit send/recv. You still need software protocols (ownership, synchronization, failure), but the access looks like memory instead of messages.</p>
<hr />
<h2 id="why-now">why now</h2>
<p><strong>The economics are painful.</strong> Memory makes up 50% of server cost and 37% of total cost of ownership in cloud environments. Three companies control DRAM production. Demand explodes from data centers, ML training, and in-memory databases. Meanwhile, clusters waste memory (the paper shows over 70% of the time, more than half of aggregate cluster memory sits unused while some machines page to disk).</p>
<p><strong>The technology finally exists.</strong> RDMA gives you single-digit microsecond latencies. But the bigger enabler is CXL (Compute eXpress Link): cache-coherent load/store access to devices over PCIe, plus a roadmap toward switching, pooling, and (eventually) shared memory fabrics.</p>
<p>Neat detail: the pool can use cheaper, denser (and potentially slower) DRAM, because it's already the "slow tier" compared to local DIMMs.</p>
<hr />
<h2 id="what-s-interesting">what's interesting</h2>
<p><strong>It's not just about capacity.</strong> Most remote memory systems (Infiniswap, Fastswap) focus on page-to-remote-RAM-instead-of-disk. Useful, but limited. The promise of CXL is memory that looks like memory: load/store access to a larger pool, and (with the right fabric features) the possibility of mapping the same bytes into multiple hosts. That's qualitatively different from "remote paging."</p>
<p><strong>The OS problems are hard.</strong> The paper is mostly about what's <em>unsolved</em>: memory allocation at scale, scheduling with memory locality, pointer sharing across servers, failure handling for "optional" memory, security for hot-swappable memory pools. These aren't incremental fixes; they require rethinking fundamental abstractions.</p>
<p><strong>The timeline matches storage disaggregation.</strong> Start small (a few hosts per pool), add switches for rack-scale, and eventually push the fabric boundary outward. Whether that ends up looking like "CXL over X" or something else is still an open question, but the trajectory rhymes with how storage disaggregation played out.</p>
<hr />
<h2 id="where-it-works-where-it-doesn-t">where it works / where it doesn't</h2>
<p><strong>Good fit:</strong></p>
<ul>
<li>Data-intensive workloads (Spark, Ray, distributed DBs) that spend cycles serializing and copying</li>
<li>Workloads with working sets that barely fit in local memory</li>
<li>Clusters with significant memory imbalance</li>
<li>Environments where memory is 50%+ of server cost</li>
</ul>
<p><strong>Bad fit:</strong></p>
<ul>
<li>Workloads that fit comfortably in local memory (you'd be adding latency for no benefit)</li>
<li>Latency-sensitive applications that can't tolerate hundreds of extra nanoseconds in their hot path</li>
<li>Traditional applications that don't share data across processes</li>
</ul>
<p>The performance trade-off: pool memory is slower than local (hundreds of ns versus ~100ns), but still orders of magnitude faster than SSD/HDD. For workloads that currently page to disk, this can be transformative. For workloads that don't, adding a slower tier may just hurt.</p>
<hr />
<h2 id="notes">notes</h2>
<ul>
<li>Paper: <a rel="external" href="https://dl.acm.org/doi/10.1145/3606557.3606563">Aguilera et al., "Memory disaggregation: why now and what are the challenges", ACM SIGOPS Operating Systems Review, 2023</a></li>
<li>This is a position paper (no benchmarks, but clear analysis of the problem space)</li>
<li>CXL 1.0: local memory expansion cards (shipping now)</li>
<li>CXL 2.0/3.0: fabric switches for pool memory (3-5 years out)</li>
<li>Latency estimates: local ~100ns, CXL local ~200-300ns, CXL pool ~500-1000ns, RDMA ~1-5μs, SSD ~100μs</li>
<li>Memory population rules (balanced channels, identical DIMMs) make incremental upgrades nearly impossible (another driver for disaggregation)</li>
<li>Distributed shared memory systems from the 90s taught us: cache coherence doesn't scale beyond rack-scale</li>
<li>Security concern: DRAM retains data residue after power-down, and pool memory is hot-swappable (encryption matters more than for local memory)</li>
<li>Related systems: Infiniswap (software paging over RDMA), LegoOS (full hardware disaggregation), The Machine (HPE, discontinued)</li>
</ul>
  
</article>
</main>
    <hr class="site-sep bottom-sep" />
    <footer class="s">
        
    </footer>
    
    <script>
        document.querySelectorAll("article img[srcset]").forEach((i) => {
            if (i.closest("a")) return;
            i.style.cursor = "pointer";
            i.onclick = () => {
                let d = document.createElement("div"),
                    s = i.srcset.split(",").pop().trim().split(" ")[0];
                d.className = "lb";
                d.innerHTML = '<img src="' + s + '">';
                document.body.style.overflow = "hidden";
                d.onclick = () => {
                    d.remove();
                    document.body.style.overflow = "";
                };
                document.body.appendChild(d);
            };
        });
    </script>
    </body>

</html>