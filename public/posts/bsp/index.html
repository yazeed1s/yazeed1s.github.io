<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>The Inner workings of BSP-Trees in the context of window management | Yazeed&#39;s blog</title>
<meta name="keywords" content="C, Spacial Data Structures, Tiling Window Manager">
<meta name="description" content="How can we use BSP-trees to store and manage windows in a 2D fashion?">
<meta name="author" content="Yazeed">
<link rel="canonical" href="https://yazeed1s.github.io/posts/bsp/">
<meta name="google-site-verification" content="XYZabc">
<meta name="yandex-verification" content="XYZabc">
<meta name="msvalidate.01" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://yazeed1s.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://yazeed1s.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://yazeed1s.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://yazeed1s.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://yazeed1s.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://yazeed1s.github.io/posts/bsp/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://yazeed1s.github.io/posts/bsp/">
  <meta property="og:site_name" content="Yazeed&#39;s blog">
  <meta property="og:title" content="The Inner workings of BSP-Trees in the context of window management">
  <meta property="og:description" content="How can we use BSP-trees to store and manage windows in a 2D fashion?">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-21T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-07-21T00:00:00+00:00">
    <meta property="article:tag" content="C">
    <meta property="article:tag" content="Spacial Data Structures">
    <meta property="article:tag" content="Tiling Window Manager">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The Inner workings of BSP-Trees in the context of window management">
<meta name="twitter:description" content="How can we use BSP-trees to store and manage windows in a 2D fashion?">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://yazeed1s.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "The Inner workings of BSP-Trees in the context of window management",
      "item": "https://yazeed1s.github.io/posts/bsp/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "The Inner workings of BSP-Trees in the context of window management",
  "name": "The Inner workings of BSP-Trees in the context of window management",
  "description": "How can we use BSP-trees to store and manage windows in a 2D fashion?",
  "keywords": [
    "C", "Spacial Data Structures", "Tiling Window Manager"
  ],
  "articleBody": " Few months back, I was sick and tired of writing work-related code, so I decided to start a side project just to revive the fun of programming in me. I had a bunch of ideas floating around in my head, but I eventually settled on creating my own tiling window manager from scratch because it was both practical and challenging. At work, I’d been diving into various spatial data structures, and one in particular caught my eye - the binary space partitioning tree (BSP-tree). I thought it would be perfect for a tiling window manager.\nFirst things first, what is a tiling window manager? Before I start talking about BSP-trees, what the heck is a tiling window manager? Fair question. Basically, it’s a type of window manager that organizes application windows in a non-overlapping manner. Unlike the usual window managers you see on OSx or Windows, where windows can stack on top of each other and overlap, tiling managers split your screen into tiles/sectons, each containing a window or a another split. As a user of a tiling window manager, you don’t have to think about where to place your windows, you just spawn a window, and bam! It’s automatically placed in the correct spot on your screen. If you’re using macOS or Windows, you’re most likely running a regular stacking window manager where windows can overlap each others.\nThese tiling managers are popular in the Linux world, but they’re not exclusive to it. I think there have been some attempts to bring DWM (a popular tiling manager) to Windows, but I can’t really vouch for how well it works. On Mac, there’s this tiling manager called Yabai that’s gained a lot of traction. It works as an extension to the built-in window manager, and from what I see online, it’s pretty solid.\nNow, the basic idea behind tiling managers is simple, but actually implementing one can get a bit tricky. Some use linked lists to keep track of windows, while others use different types of trees. Personally, I think trees are a better fit for this kind of job. They’re naturally hierarchical, which matches up nicely with how windows are typically arranged on a screen.\nThe issue with linked-lists Using a linked-list to manage windows has its drawbacks, even though it might seem easier to implement at first glance. The main issue is that linked lists are basically just a straight line of data (linear data structure). When we think about how windows are arranged on a screen, especially when they’re not overlapping, it’s clear that it’s not a simple line-up. Instead, they forms a more complex, multi-dimensional and hierarchical structure.\nIn fact, even with regular overlapping windows, you’ve got this whole complex spatial relationship going on. Some windows might be covering part of the screen, others might be hiding behind them, and some might be off in their own corner. This goes beyond simple linear ordering.\nBecause of this mismatch between the linear nature of linked lists and the multi-dimensional layout of windows, using them for window management means you end up having to do a ton of complicated math to figure out where everything should go. Every time you add a new window or close one, you need to recalculate all these rectangles to keep everything in place. You basically need to translate a one-dimensional data structure into a multi-dimensional screen layout, which is hard.\nTrees actually handle it better! Trees on the other hand are more intuitive in this context, they’re hierarchical by nature and can easily be used to emulate multi-dimensional screen layouts. The structure of a tree naturally maps to the way windows are typically arranged on a screen, you can use some nodes to represent different areas of the screen, and others to represent the actual windows. It’s a much more intuitive way to think about the layout, and it makes a lot of operations simpler to implement.\nBinary space partitioning (BSP) tree We’re talking about BSP-trees here. It’s a fancy name, but the concept is pretty straightforward. Imagine starting with your entire computer screen and drawing a vertical line to divide it in half. Then, you take each of those halves and split it again horizontally or vertically, keep doing this over and over, and you’ve got yourself a BSP tree. In this tree, the whole space (like your full screen) is the root, each split creates two new branches, and the smallest divisions become the leaves of the tree.\nNow, in any tree structure, we have three types of nodes:\nThe root - it’s the boss, sitting at the top. Internal nodes - they’ve got kids (other nodes) under them. External nodes (or leaves) - they don’t have any nodes under them. In a BSP-tree, the internal nodes represent different sections of the screen, while the leaves represent actual application windows.\nWhen I was building my own tiling window manager, I looked at a bunch of different ways people had implemented BSP trees. Most of the implementations I came across kept things pretty simple, they didn’t bother including a parent node in each node of the tree. Instead, the typical structure was something like this: each node would just keep track of its two children along with other implementation-specific data.\nThis approach was really common. I kept seeing it over and over in different implementations. They’d have the two child nodes and maybe some other stuff, but no direct link back to the parent.\nSo, a node in a BSP tree can be defined in two ways:\nWithout a parent pointer: typedef struct node_t node_t; struct node_t { node_t\t*first_child; node_t\t*second_child; client_t *client; // window node_type_t node_type; rectangle_t rectangle; rectangle_t parent_rectangle; ... }; With a parent pointer: typedef struct node_t node_t; struct node_t { node_t\t*parent; node_t\t*first_child; node_t\t*second_child; client_t *client; // window node_type_t node_type; rectangle_t rectangle; ... }; The approach without a parent pointer is simpler and uses less memory. But it has some drawbacks. When you’re adding new nodes or doing other operations like resizing or splitting, you need to explicitly pass along the parent’s rectangle info (this isn’t a real problem but I am lazy I guess). And when you want to check if a sibling is external or internal, well good luck with that, you end up writing a bunch of code just to access the sibling. Plus, if you ever need to move up the tree, you might need to get creative or use some extra data structures or complicated algorithms that I can’t come up with.\nOn the other hand, including a parent pointer uses a tiny bit more memory, but it makes life so much easier in other ways. Need to move up the tree? No problem. Checking siblings? Piece of cake. The only real downside is that you’ve got to be extra careful when you’re deleting nodes so that you don’t leave dangling pointers behind.\nIn my implementation, I chose to include the parent pointer. Yeah, it uses slightly more memory, but the ease of use and simpler coding made it totally worth it (again, im lazy).\nUsing a BSP-tree to manage windows When it comes to actually managing windows with a BSP-tree, there’s a lot to consider. I’ll walk you through how I handle inserting and deleting windows in my implementation. Keep in mind, this might not be the most optimal approach for every situation, but it worked well for what I needed and I don’t care.\nInsertion in a BSP-tree To understand the insertion process in a BSP-tree, let’s start by defining the rules for the tree:\nThe tree is a partition of a monitor’s rectangle into smaller rectangular regions. Each leaf node holds exactly one window. Each node in a bsp-tree either has ZERO or TWO children. Each internal node is responsible for splitting a rectangle in half. Window Split logic Now, here’s the logic for doing all the partitioning:\nLet’s say you have a node (we’ll call it Node X) that’s currently holding a window. Then you decide to open a new window (let’s call this one Node B). What happens is simple. Node X goes from being a simple leaf to becoming a parent (from external to internal) and the window it was holding gets moved into a new child node (Node A), and your new window becomes its other child (Node B).\nNode X’s rectangle then gets split in half to make room for both of these new nodes. When we split Node X’s rectangle, we look at its dimensions to decide whether to cut it horizontally or vertically, If it’s taller than it is wide, we’ll cut horizontally, otherwise we’ll cut vertically. This split ends up creating two new rectangles for Node A and Node B, and both of these new rectangles fit entirely within Node X’s original space.\nAs you can tell, rectagnles can contain other rectangles or be contained wihin other rectangles.\nLet’s look at some code for inserting and splitting:\nvoid split_node(node_t *n) { // vertical split (side by side) if (n-\u003erectangle.width \u003e= n-\u003erectangle.height) { // set up the first child (left side) n-\u003efirst_child-\u003erectangle.x = n-\u003erectangle.x; n-\u003efirst_child-\u003erectangle.y = n-\u003erectangle.y; n-\u003efirst_child-\u003erectangle.width = n-\u003erectangle.width / 2; n-\u003efirst_child-\u003erectangle.height = n-\u003erectangle.height; // set up the second child (right side) n-\u003esecond_child-\u003erectangle.x = n-\u003erectangle.x + n-\u003efirst_child-\u003erectangle.width; n-\u003esecond_child-\u003erectangle.y = n-\u003erectangle.y; n-\u003esecond_child-\u003erectangle.width = n-\u003erectangle.width - n-\u003efirst_child-\u003erectangle.width; n-\u003esecond_child-\u003erectangle.height = n-\u003erectangle.height; } else { // horizontal split (top and bottom) // set up the first child (top) n-\u003efirst_child-\u003erectangle.x\t= n-\u003erectangle.x; n-\u003efirst_child-\u003erectangle.y\t= n-\u003erectangle.y; n-\u003efirst_child-\u003erectangle.width = n-\u003erectangle.width; n-\u003efirst_child-\u003erectangle.height = n-\u003erectangle.height / 2; // set up the second child (bottom) n-\u003esecond_child-\u003erectangle.x = n-\u003erectangle.x; n-\u003esecond_child-\u003erectangle.y = n-\u003erectangle.y + n-\u003efirst_child-\u003erectangle.height; n-\u003esecond_child-\u003erectangle.width = n-\u003erectangle.width; n-\u003esecond_child-\u003erectangle.height = n-\u003erectangle.height - n-\u003efirst_child-\u003erectangle.height; } } void insert_node(node_t *existing_node, node_t *new_node) { if (existing_node == NULL || existing_node-\u003eclient == NULL || new_node == NULL) { _LOG_(ERROR, \"Invalid node or client\"); return; } assert(existing_node-\u003enode_type = EXTERNAL_NODE); // set existing_node type to INTERNAL_NODE if (!IS_ROOT(existing_node)) { existing_node-\u003enode_type = INTERNAL_NODE; } // move existing_node client data to the first child existing_node-\u003efirst_child = create_node(existing_node-\u003eclient); if (existing_node-\u003efirst_child == NULL) { return; } existing_node-\u003efirst_child-\u003eparent = existing_node; existing_node-\u003efirst_child-\u003enode_type = EXTERNAL_NODE; existing_node-\u003eclient = NULL; // assign the new node as the second child existing_node-\u003esecond_child = new_node; existing_node-\u003esecond_child-\u003eparent = existing_node; existing_node-\u003esecond_child-\u003enode_type = EXTERNAL_NODE; // split split_node(existing_node); } I know code can be a bit overwhelming sometimes, so let’s walk through this BSP-tree concept with some visuals. It’ll make things much clearer.\nYou’re starting with a completely empty screen. In BSP-tree terms, this is super simple - it’s just a single node marked as NULL and It would exactly look like this: Adding the First Window Now, let’s say you open your first window. Boom! It takes over the entire screen.\nIn our BSP tree, this becomes the root node. It’s got all the info about the window and covers the whole screen.\nAdding the Second Window Things get more interesting when you open a second window. The BSP tree gets clever here. It splits the screen in two, creating two child nodes under the root. Your first window slides into one of these nodes, and the new window goes into the other.\nThe root node is now overseeing both children but not directly containing a window itself.\nAdding the Third Window Adding a third window gets even more interesting.\nWe pick one of the existing nodes (in this case, the right one) and splits it again. Now we’ve got three leaf nodes, each with a window, and a couple of internal nodes keeping things organized.\nAdding the Fourth Window By the time you get to four windows, you can really appreciate the system. The tree splits another leaf node, and now you’ve got this neat structure with four windows, each in its own leaf node, and a few internal nodes managing the layout.\nEvery time the tree splits, it’s making a decision to divide the screen either horizontally or vertically. No matter how many windows you open, the tree can always find a way to divide up the screen. And when you want to close a window or resize things? You just need to reuse the parent’s rectangle of your targeted node.\nDeletion in a BSP-tree. When deleting a node from the tree, we encounter two main scenarios:\nThe targeted node has an external sibling. The targeted node doesn’t have a grandparent. The targeted node has a grandparent (its parent is the root of the tree). The targeted node has an internal sibling. The targeted node doesn’t have a grandparent. The targeted node has a grandparent (its parent is the root of the tree). Let’s look at how these scenarios can be handled:\nCase 1: External Sibling External Sibling with No Grandparent Let’s consider the following scenario. We have Node C, and it’s got an external sibling and no grandparent! How can we remove it from the tree?\nWe want to delete Node C from the tree First, we need to remove the parent-child links between node A and node C. We basically need to set child-\u003eparent to NULL and parent-\u003echild to NULL as well. Now we have the links removed, we move the window from node B to node A, node B becomes empty. Now that node B is practically empty, we can remove the parent-child links between node A and node B. Both node B and node C will be unlinked from their parent node A. We can safely free node B and node C and resize the tree if we need to. The difference between the initial and final state is as follows:\nExternal Sibling with Grandparent Let’s consider another scenario. We have Node C, and it’s got an external sibling and a grandparent! How can we remove it from the tree?\nWe want to delete Node C from the tree First, node A is internal, it represents a rectangle in the screen we aim to make it external by deleting its children and inserting a window in it We start by removing the parent-child links between Node A ⇄ Node Cand Node A ⇄ Node B. We basically need to set child-\u003eparent to NULL and parent-\u003echild to NULL as well. Now we have the links removed, we move window 2 from node B to node A, node B becomes empty. Both node B and node C will be unlinked from their parent node A. We can safely free node B and node C and do resizing if needed. Finally we change node A type from INTERNAL_NODE to EXTERNAL_NODE The difference between the initial and final state is as follows:\nThe code for both scenarios will pretty much look like this:\nif (is_sibling_external(node)) { node_t *e = get_external_sibling(node); if (e == NULL) { return; } // if I has no parent if (IS_ROOT(node-\u003eparent)) { node-\u003eparent-\u003eclient\t= e-\u003eclient; node-\u003eparent-\u003efirst_child = NULL; node-\u003eparent-\u003esecond_child = NULL; } else { // if I has a prent node_t *g = node-\u003eparent-\u003eparent; if (g-\u003efirst_child == node-\u003eparent) { g-\u003efirst_child-\u003enode_type\t= EXTERNAL_NODE; g-\u003efirst_child-\u003eclient\t= e-\u003eclient; g-\u003efirst_child-\u003efirst_child\t= NULL; g-\u003efirst_child-\u003esecond_child = NULL; } else { g-\u003esecond_child-\u003enode_type\t= EXTERNAL_NODE; g-\u003esecond_child-\u003eclient\t= e-\u003eclient; g-\u003esecond_child-\u003efirst_child = NULL; g-\u003esecond_child-\u003esecond_child = NULL; } } e-\u003eparent = NULL; free(e); e\t= NULL; node-\u003eparent = NULL; free(node); node = NULL; } Case 2: Internal sibling Internal sibling with no grandparent Now if the targeted node has a an internal sibling, then a little extra work is required Lets consider the following scenario, we want to delete Node EA (window 1) from the tree. but its siblingNode Ais an internal node with children (Node B and Node C).\nHow can we delete it?\nWe want to delete Node EA (window 1) from the tree. However, its siblingNode Ais an internal node with children (Node B and Node C). The goal is to restructure the tree so that Node B (window 2) and Node C (window 3) become direct children of Node PA, and then remove Node EA and Node A entirely. First, Node A is an internal node representing a rectangle in the screen. To delete Node A, we need to first unlink it from its children. We start by removing the parent⇄child links between (node A ⇄ node C and node A ⇄ node B). We basically need to set child-\u003eparent to NULL and parent-\u003echild to NULL as well. Then we remove the parent⇄child links between (node PA ⇄ node EA and node PA ⇄ node A). again we basically need to set child-\u003eparent to NULL and parent-\u003echild to NULL as well. Finally we link Node C and Node B to Node PA After all that we free Node A and Node EA and resize the tree The difference between the initial and final state is as follows:\nOr a shorter version:\nInternal sibling with grandparent Now if the targeted node has a an internal sibling, and a grandparent then the logic will prety much be the same. We just need to find the psrent of the targeted node, get rid of the targeted node and its sibling then and link its children to the targeted node’s parent (to their grandparent).\nJust like what the visual show, this is the initial state:\nAnd this is how things look at the end:\nThe code for both scenarios will pretty much look like this:\nif (is_sibling_internal(node)) { node_t *n = NULL; // if IN has no parent if (IS_ROOT(node-\u003eparent)) { n = get_internal_sibling(node); if (n == NULL) { _LOG_(ERROR, \"internal node is null\"); return; } if (d-\u003etree == node-\u003eparent) { d-\u003etree-\u003efirst_child\t= n-\u003efirst_child; n-\u003efirst_child-\u003eparent\t= d-\u003etree; d-\u003etree-\u003esecond_child\t= n-\u003esecond_child; n-\u003esecond_child-\u003eparent = d-\u003etree; } else { d-\u003etree-\u003esecond_child\t= n-\u003efirst_child; n-\u003efirst_child-\u003eparent\t= d-\u003etree; d-\u003etree-\u003efirst_child\t= n-\u003esecond_child; n-\u003esecond_child-\u003eparent = d-\u003etree; } } else { // if IN has a parent if (is_sibling_internal(node)) { n = get_internal_sibling(node); } else { _LOG_(ERROR, \"internal node is null\"); return; } if (n == NULL) return; if (node-\u003eparent-\u003efirst_child == node) { node-\u003eparent-\u003efirst_child = n-\u003efirst_child; n-\u003efirst_child-\u003eparent\t= node-\u003eparent; node-\u003eparent-\u003esecond_child = n-\u003esecond_child; n-\u003esecond_child-\u003eparent\t= node-\u003eparent; } else { node-\u003eparent-\u003esecond_child = n-\u003efirst_child; n-\u003efirst_child-\u003eparent\t= node-\u003eparent; node-\u003eparent-\u003efirst_child = n-\u003esecond_child; n-\u003esecond_child-\u003eparent\t= node-\u003eparent; } } n-\u003eparent\t= NULL; n-\u003efirst_child\t= NULL; n-\u003esecond_child = NULL; node-\u003eparent\t= NULL; free(n); n = NULL; free(node); node = NULL; } Cool fact about the tree. Hopefully, by now, you can see that continuously opening windows on one side of the screen won’t result in an extremely skewed tree forming a linked list. This is because BSP tree nodes can ONLY have two or zero children.\nBut, we can easily end up with an unbalanced tree, we need to write a balancing algorithm to fix it.\nThe end So, there you have it. Using bsp-trees for managing windows in a tiling window manager isn’t just a fancy idea — it actually makes a lot of sense. I had so much fun Implementing this tree into my window manager, I learned a lot and banged my head against the wall more than a few times, but in the end, it was all worth it.\n",
  "wordCount" : "3150",
  "inLanguage": "en",
  "datePublished": "2024-07-21T00:00:00Z",
  "dateModified": "2024-07-21T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Yazeed"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://yazeed1s.github.io/posts/bsp/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Yazeed's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://yazeed1s.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://yazeed1s.github.io/" accesskey="h" title="Yazeed&#39;s blog (Alt + H)">Yazeed&#39;s blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://yazeed1s.github.io/" title="Home">
                    <span><span data-feather='github'></span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://yazeed1s.github.io/archives/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://yazeed1s.github.io/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://yazeed1s.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      The Inner workings of BSP-Trees in the context of window management
    </h1>
    <div class="post-description">
      How can we use BSP-trees to store and manage windows in a 2D fashion?
    </div>
    <div class="post-meta"><span title='2024-07-21 00:00:00 +0000 UTC'>July 21, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;3150 words&nbsp;·&nbsp;Yazeed

</div>
  </header> 
  <div class="post-content"><hr>
<p>Few months back, I was sick and tired of writing work-related code, so I decided to start a side project just to revive the fun of programming in me. I had a bunch of ideas floating around in my head, but I eventually settled on creating my own tiling window manager from scratch because it was both practical and challenging. At work, I&rsquo;d been diving into various spatial data structures, and one in particular caught my eye - the binary space partitioning tree (<a href="https://en.wikipedia.org/wiki/Binary_space_partitioning">BSP-tree</a>). I thought it would be perfect for a tiling window manager.</p>
<hr>
<h2 id="first-things-first-what-is-a-tiling-window-manager">First things first, what is a tiling window manager?<a hidden class="anchor" aria-hidden="true" href="#first-things-first-what-is-a-tiling-window-manager">#</a></h2>
<p>Before I start talking about BSP-trees, what the heck is a tiling window manager? Fair question. Basically, it&rsquo;s a type of window manager that organizes application windows in a <strong>non-overlapping</strong> manner. Unlike the usual window managers you see on OSx or Windows, where windows can stack on top of each other and overlap, tiling managers split your screen into <strong>tiles/sectons</strong>, each containing a window or a another split. As a user of a tiling window manager, you don&rsquo;t have to think about where to place your windows, you just spawn a window, and bam! It&rsquo;s automatically placed in the correct spot on your screen. If you&rsquo;re using macOS or Windows, you&rsquo;re most likely running a regular stacking window manager where windows can overlap each others.</p>
<p>These tiling managers are popular in the Linux world, but they&rsquo;re not exclusive to it. I think there have been some attempts to bring DWM (a popular tiling manager) to Windows, but I can&rsquo;t really vouch for how well it works. On Mac, there&rsquo;s this tiling manager called <a href="https://github.com/koekeishiya/yabai">Yabai</a> that&rsquo;s gained a lot of traction. It works as an extension to the built-in window manager, and from what I see online, it&rsquo;s pretty solid.</p>
<p>Now, the basic idea behind tiling managers is simple, but actually implementing one can get a bit tricky. Some use linked lists to keep track of windows, while others use different types of trees. Personally, I think trees are a better fit for this kind of job. They&rsquo;re naturally hierarchical, which matches up nicely with how windows are typically arranged on a screen.</p>
<h4 id="the-issue-with-linked-lists">The issue with linked-lists<a hidden class="anchor" aria-hidden="true" href="#the-issue-with-linked-lists">#</a></h4>
<p>Using a linked-list to manage windows has its drawbacks, even though it might seem easier to implement at first glance. The main issue is that linked lists are basically just a straight line of data (linear data structure). When we think about how windows are arranged on a screen, especially when they&rsquo;re not overlapping, it&rsquo;s clear that it&rsquo;s not a simple line-up. Instead, they forms a more complex, multi-dimensional and hierarchical structure.</p>
<p>In fact, even with regular overlapping windows, you&rsquo;ve got this whole complex spatial relationship going on. Some windows might be covering part of the screen, others might be hiding behind them, and some might be off in their own corner. This goes beyond simple linear ordering.</p>
<p>Because of this mismatch between the linear nature of linked lists and the multi-dimensional layout of windows, using them for window management means you end up having to do a ton of complicated math to figure out where everything should go. Every time you add a new window or close one, you need to recalculate all these rectangles to keep everything in place. You basically need to translate a one-dimensional data structure into a multi-dimensional screen layout, which is hard.</p>
<h4 id="trees-actually-handle-it-better">Trees actually handle it better!<a hidden class="anchor" aria-hidden="true" href="#trees-actually-handle-it-better">#</a></h4>
<p>Trees on the other hand are more intuitive in this context, they&rsquo;re hierarchical by nature and can easily be used to emulate multi-dimensional screen layouts. The structure of a tree naturally maps to the way windows are typically arranged on a screen, you can use some nodes to represent different areas of the screen, and others to represent the actual windows. It&rsquo;s a much more intuitive way to think about the layout, and it makes a lot of operations simpler to implement.</p>
<h2 id="binary-space-partitioning-bsp-tree">Binary space partitioning (BSP) tree<a hidden class="anchor" aria-hidden="true" href="#binary-space-partitioning-bsp-tree">#</a></h2>
<p>We&rsquo;re talking about BSP-trees here. It&rsquo;s a fancy name, but the concept is pretty straightforward. Imagine starting with your entire computer screen and drawing a vertical line to divide it in half. Then, you take each of those halves and split it again horizontally or vertically, keep doing this over and over, and you&rsquo;ve got yourself a BSP tree. In this tree, the whole space (like your full screen) is the root, each split creates two new branches, and the smallest divisions become the leaves of the tree.</p>
<p>Now, in any tree structure, we have three types of nodes:</p>
<ul>
<li>The root - it&rsquo;s the boss, sitting at the top.</li>
<li>Internal nodes - they&rsquo;ve got kids (other nodes) under them.</li>
<li>External nodes (or leaves) - they don&rsquo;t have any nodes under them.</li>
</ul>
<p>In a BSP-tree, the internal nodes represent different sections of the screen, while the leaves represent actual application windows.</p>
<p>When I was building my own tiling window manager, I looked at a bunch of different ways people had implemented BSP trees. Most of the implementations I came across kept things pretty simple, they didn&rsquo;t bother including a parent node in each node of the tree. Instead, the typical structure was something like this: each node would just keep track of its two children along with other implementation-specific data.</p>
<p>This approach was really common. I kept seeing it over and over in different implementations. They&rsquo;d have the two child nodes and maybe some other stuff, but no direct link back to the parent.</p>
<p>So, a node in a BSP tree can be defined in two ways:</p>
<ol>
<li>Without a parent pointer:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="kt">node_t</span> <span class="kt">node_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="kt">node_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">node_t</span>	   <span class="o">*</span><span class="n">first_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">node_t</span>	   <span class="o">*</span><span class="n">second_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">client_t</span>   <span class="o">*</span><span class="n">client</span><span class="p">;</span> <span class="c1">// window
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">node_type_t</span> <span class="n">node_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">rectangle_t</span> <span class="n">rectangle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">rectangle_t</span> <span class="n">parent_rectangle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><ol start="2">
<li>With a parent pointer:</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="kt">node_t</span> <span class="kt">node_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="kt">node_t</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">node_t</span>	   <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">node_t</span>	   <span class="o">*</span><span class="n">first_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">node_t</span>	   <span class="o">*</span><span class="n">second_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">client_t</span>   <span class="o">*</span><span class="n">client</span><span class="p">;</span> <span class="c1">// window
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kt">node_type_t</span> <span class="n">node_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">rectangle_t</span> <span class="n">rectangle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>The approach without a parent pointer is simpler and uses less memory. But it has some drawbacks. When you&rsquo;re adding new nodes or doing other operations like resizing or splitting, you need to explicitly pass along the parent&rsquo;s rectangle info (this isn&rsquo;t a real problem but I am lazy I guess). And when you want to check if a sibling is external or internal, well good luck with that, you end up writing a bunch of code just to access the sibling. Plus, if you ever need to move up the tree, you might need to get creative or use some extra data structures or complicated algorithms that I can&rsquo;t come up with.</p>
<p>On the other hand, including a parent pointer uses a tiny bit more memory, but it makes life so much easier in other ways. Need to move up the tree? No problem. Checking siblings? Piece of cake. The only real downside is that you&rsquo;ve got to be extra careful when you&rsquo;re deleting nodes so that you don&rsquo;t leave dangling pointers behind.</p>
<p>In my implementation, I chose to include the parent pointer. Yeah, it uses slightly more memory, but the ease of use and simpler coding made it totally worth it (again, im lazy).</p>
<h2 id="using-a-bsp-tree-to-manage-windows">Using a BSP-tree to manage windows<a hidden class="anchor" aria-hidden="true" href="#using-a-bsp-tree-to-manage-windows">#</a></h2>
<p>When it comes to actually managing windows with a BSP-tree, there&rsquo;s a lot to consider. I&rsquo;ll walk you through how I handle inserting and deleting windows in my implementation. Keep in mind, this might not be the most optimal approach for every situation, but it worked well for what I needed and I don&rsquo;t care.</p>
<h2 id="insertion-in-a-bsp-tree">Insertion in a BSP-tree<a hidden class="anchor" aria-hidden="true" href="#insertion-in-a-bsp-tree">#</a></h2>
<p>To understand the insertion process in a BSP-tree, let&rsquo;s start by defining the rules for the tree:</p>
<ul>
<li>The tree is a <strong>partition</strong> of a monitor&rsquo;s rectangle into smaller rectangular regions.</li>
<li>Each leaf node holds <strong>exactly</strong> one window.</li>
<li>Each node in a bsp-tree either has <strong>ZERO</strong> or <strong>TWO</strong> children.</li>
<li>Each internal node is responsible for splitting a rectangle in half.</li>
</ul>
<h3 id="window-split-logic">Window Split logic<a hidden class="anchor" aria-hidden="true" href="#window-split-logic">#</a></h3>
<p>Now, here&rsquo;s the logic for doing all the partitioning:</p>
<p>Let&rsquo;s say you have a node (we&rsquo;ll call it <code>Node X</code>) that&rsquo;s currently holding a window. Then you decide to open a new window (let&rsquo;s call this one <code>Node B</code>). What happens is simple. <code>Node X</code> goes from being a simple leaf to becoming a parent (from <strong>external</strong> to <strong>internal</strong>) and the window it was holding gets moved into a <strong>new child node</strong> (<code>Node A</code>), and your new window becomes its <strong>other child</strong> (<code>Node B</code>).</p>
<p><code>Node X</code>&rsquo;s rectangle then gets split in half to make room for both of these new nodes. When we split <code>Node X</code>&rsquo;s rectangle, we look at its dimensions to decide whether to cut it horizontally or vertically, If it&rsquo;s taller than it is wide, we&rsquo;ll cut horizontally, otherwise we&rsquo;ll cut vertically. This split ends up creating two new rectangles for <code>Node A</code> and <code>Node B</code>, and both of these new rectangles fit <strong>entirely</strong> within <code>Node X</code>&rsquo;s original space.</p>
<p>As you can tell, rectagnles can contain other rectangles or be contained wihin other rectangles.</p>
<hr>
<p>Let&rsquo;s look at some code for inserting and splitting:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">split_node</span><span class="p">(</span><span class="kt">node_t</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// vertical split (side by side)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// set up the first child (left side)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// set up the second child (right side)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// horizontal split (top and bottom)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// set up the first child (top)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">x</span>		<span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">y</span>		<span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// set up the second child (bottom)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> 
</span></span><span class="line"><span class="cl"><span class="nf">insert_node</span><span class="p">(</span><span class="kt">node_t</span> <span class="o">*</span><span class="n">existing_node</span><span class="p">,</span> <span class="kt">node_t</span> <span class="o">*</span><span class="n">new_node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">existing_node</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">client</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">new_node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">_LOG_</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="s">&#34;Invalid node or client&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">assert</span><span class="p">(</span><span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">EXTERNAL_NODE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// set existing_node type to INTERNAL_NODE
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">IS_ROOT</span><span class="p">(</span><span class="n">existing_node</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">INTERNAL_NODE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// move existing_node client data to the first child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">=</span> <span class="nf">create_node</span><span class="p">(</span><span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">existing_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">EXTERNAL_NODE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">client</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// assign the new node as the second child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">second_child</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">existing_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">existing_node</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">EXTERNAL_NODE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// split 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">split_node</span><span class="p">(</span><span class="n">existing_node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>I know code can be a bit overwhelming sometimes, so let&rsquo;s walk through this BSP-tree concept with some visuals. It&rsquo;ll make things much clearer.</p>
<p>You&rsquo;re starting with a completely empty screen. In BSP-tree terms, this is super simple - it&rsquo;s just a single node marked as NULL and It would exactly look like this:
<img alt="Figure" loading="lazy" src="/images/bsp/bsp-null.png" title="Empty"></p>
<h3 id="adding-the-first-window">Adding the First Window<a hidden class="anchor" aria-hidden="true" href="#adding-the-first-window">#</a></h3>
<p>Now, let&rsquo;s say you open your first window. Boom! It takes over the entire screen.</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-1w.png" title="Preview"></p>
<p>In our BSP tree, this becomes the root node. It&rsquo;s got all the info about the window and covers the whole screen.</p>
<h3 id="adding-the-second-window">Adding the Second Window<a hidden class="anchor" aria-hidden="true" href="#adding-the-second-window">#</a></h3>
<p>Things get more interesting when you open a second window. The BSP tree gets clever here. It splits the screen in two, creating two child nodes under the root. Your first window slides into one of these nodes, and the new window goes into the other.</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-2w.png" title="2nd-window"></p>
<p>The root node is now overseeing both children but not directly containing a window itself.</p>
<h3 id="adding-the-third-window">Adding the Third Window<a hidden class="anchor" aria-hidden="true" href="#adding-the-third-window">#</a></h3>
<p>Adding a third window gets even more interesting.</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-3w.png" title="3rd-window"></p>
<p>We pick one of the existing nodes (in this case, the right one) and splits it again. Now we&rsquo;ve got three leaf nodes, each with a window, and a couple of internal nodes keeping things organized.</p>
<h3 id="adding-the-fourth-window">Adding the Fourth Window<a hidden class="anchor" aria-hidden="true" href="#adding-the-fourth-window">#</a></h3>
<p>By the time you get to four windows, you can really appreciate the system. The tree splits another leaf node, and now you&rsquo;ve got this neat structure with four windows, each in its own leaf node, and a few internal nodes managing the layout.</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-4w.png" title="4th-window"></p>
<p>Every time the tree splits, it&rsquo;s making a decision to divide the screen either horizontally or vertically. No matter how many windows you open, the tree can always find a way to divide up the screen. And when you want to close a window or resize things? You just need to reuse the parent&rsquo;s rectangle of your targeted node.</p>
<h2 id="deletion-in-a-bsp-tree">Deletion in a BSP-tree.<a hidden class="anchor" aria-hidden="true" href="#deletion-in-a-bsp-tree">#</a></h2>
<p>When deleting a node from the tree, we encounter two main scenarios:</p>
<ol>
<li>The targeted node has an external sibling.
<ul>
<li>The targeted node doesn&rsquo;t have a grandparent.</li>
<li>The targeted node has a grandparent (its parent is the root of the tree).</li>
</ul>
</li>
<li>The targeted node has an internal sibling.
<ul>
<li>The targeted node doesn&rsquo;t have a grandparent.</li>
<li>The targeted node has a grandparent (its parent is the root of the tree).</li>
</ul>
</li>
</ol>
<p>Let&rsquo;s look at how these scenarios can be handled:</p>
<h3 id="case-1-external-sibling">Case 1: External Sibling<a hidden class="anchor" aria-hidden="true" href="#case-1-external-sibling">#</a></h3>
<h4 id="external-sibling-with-no-grandparent">External Sibling with No Grandparent<a hidden class="anchor" aria-hidden="true" href="#external-sibling-with-no-grandparent">#</a></h4>
<p>Let&rsquo;s consider the following scenario. We have Node C, and it&rsquo;s got an external sibling and no grandparent! How can we remove it from the tree?</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-del01.png" title="Preview"></p>
<ul>
<li>We want to delete <code>Node C</code> from the tree</li>
<li>First, we need to remove the <code>parent-child</code> links between <code>node A</code> and <code>node C</code>.
<ul>
<li>We basically need to set child-&gt;parent to <strong>NULL</strong> and parent-&gt;child to <strong>NULL</strong> as well.</li>
</ul>
</li>
<li>Now we have the links removed, we move the window from
<code>node B</code> to <code>node A</code>, <code>node B</code> becomes empty.</li>
<li>Now that <code>node B</code> is practically empty, we can remove the parent-child links
between <code>node A</code> and <code>node B</code>.</li>
<li>Both <code>node B</code> and <code>node C</code> will be unlinked from their parent <code>node A</code>.</li>
<li>We can safely free <code>node B</code> and <code>node C</code> and resize the tree if we need to.</li>
</ul>
<p>The difference between the initial and final state is as follows:</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-del02.png" title="Preview"></p>
<h4 id="external-sibling-with-grandparent">External Sibling with Grandparent<a hidden class="anchor" aria-hidden="true" href="#external-sibling-with-grandparent">#</a></h4>
<p>Let&rsquo;s consider another scenario. We have Node C, and it&rsquo;s got an external sibling and a grandparent! How can we remove it from the tree?</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-del11.png" title="Preview"></p>
<ul>
<li>We want to delete <code>Node C</code> from the tree</li>
<li>First, <code>node A</code> is internal, it represents a rectangle in the screen
we aim to make it external by deleting its children and inserting a window in it</li>
<li>We start by removing the parent-child links between <code>Node A</code> ⇄ <code>Node C</code>and <code>Node A</code> ⇄ <code>Node B</code>.
<ul>
<li>We basically need to set child-&gt;parent to <strong>NULL</strong> and parent-&gt;child to <strong>NULL</strong> as well.</li>
</ul>
</li>
<li>Now we have the links removed, we move window 2 from
<code>node B</code> to <code>node A</code>, <code>node B</code> becomes empty.</li>
<li>Both <code>node B</code> and <code>node C</code> will be unlinked from their parent <code>node A</code>.</li>
<li>We can safely free <code>node B</code> and <code>node C</code> and do resizing if needed.</li>
<li>Finally we change <code>node A</code> type from <code>INTERNAL_NODE</code> to <code>EXTERNAL_NODE</code></li>
</ul>
<p>The difference between the initial and final state is as follows:</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-del12.png" title="Preview"></p>
<p>The code for both scenarios will pretty much look like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">is_sibling_external</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">node_t</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="nf">get_external_sibling</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// if I has no parent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="nf">IS_ROOT</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">client</span>	   <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">first_child</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">second_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// if I has a prent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kt">node_t</span> <span class="o">*</span><span class="n">g</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">g</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">node_type</span>	 <span class="o">=</span> <span class="n">EXTERNAL_NODE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">g</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">client</span>		 <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">g</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">first_child</span>	 <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">g</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">second_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">g</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">node_type</span>	  <span class="o">=</span> <span class="n">EXTERNAL_NODE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">g</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">client</span>		  <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">client</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">g</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">first_child</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">g</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">second_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">e</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">free</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">e</span>			 <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">free</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="case-2-internal-sibling">Case 2: Internal sibling<a hidden class="anchor" aria-hidden="true" href="#case-2-internal-sibling">#</a></h3>
<h4 id="internal-sibling-with-no-grandparent">Internal sibling with no grandparent<a hidden class="anchor" aria-hidden="true" href="#internal-sibling-with-no-grandparent">#</a></h4>
<p>Now if the targeted node has a an internal sibling, then a little extra work is required
Lets consider the following scenario, we want to delete <code>Node EA (window 1)</code> from the tree. but its sibling<code>Node A</code>is an internal node with children <code>(Node B and Node C)</code>.</p>
<p>How can we delete it?</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-del21.png" title="del1"></p>
<ul>
<li>We want to delete <code>Node EA (window 1)</code> from the tree. However,
its sibling<code>Node A</code>is an internal node with children <code>(Node B and Node C)</code>.</li>
<li>The goal is to restructure the tree so that <code>Node B (window 2)</code> and <code>Node C (window 3)</code>
become direct children of <code>Node PA</code>, and then remove <code>Node EA</code> and <code>Node A</code> entirely.</li>
<li>First, <code>Node A</code> is an internal node representing a rectangle in the screen.
To delete <code>Node A</code>, we need to first unlink it from its children.</li>
<li>We start by removing the parent⇄child links
between (<code>node A</code> ⇄ <code>node C</code> and <code>node A</code> ⇄ <code>node B</code>).
<ul>
<li>We basically need to set child-&gt;parent to <strong>NULL</strong> and parent-&gt;child to <strong>NULL</strong> as well.</li>
</ul>
</li>
<li>Then we remove the parent⇄child links between (node PA ⇄ node EA and node PA ⇄ <code>node A</code>).
<ul>
<li>again we basically need to set child-&gt;parent to <strong>NULL</strong> and parent-&gt;child to <strong>NULL</strong> as well.</li>
</ul>
</li>
<li>Finally we link <code>Node C</code> and <code>Node B</code> to <code>Node PA</code></li>
<li>After all that we free <code>Node A</code> and <code>Node EA</code> and resize the tree</li>
</ul>
<p>The difference between the initial and final state is as follows:</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-del22.png" title="del2"></p>
<p>Or a shorter version:</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-del23.png" title="del3"></p>
<h4 id="internal-sibling-with-grandparent">Internal sibling with grandparent<a hidden class="anchor" aria-hidden="true" href="#internal-sibling-with-grandparent">#</a></h4>
<p>Now if the targeted node has a an internal sibling, and a grandparent then the logic will prety much be the same. We just need to find the psrent of the targeted node, get rid of the targeted node and its sibling then and link its children to the targeted node&rsquo;s parent (to their grandparent).</p>
<p>Just like what the visual show, this is the initial state:</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-final.png" title="del4"></p>
<p>And this is how things look at the end:</p>
<p><img alt="Figure" loading="lazy" src="/images/bsp/bsp-final2.png" title="del4"></p>
<p>The code for both scenarios will pretty much look like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nf">is_sibling_internal</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">node_t</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// if IN has no parent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">(</span><span class="nf">IS_ROOT</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">n</span> <span class="o">=</span> <span class="nf">get_internal_sibling</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">_LOG_</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="s">&#34;internal node is null&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">tree</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">d</span><span class="o">-&gt;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">first_child</span>	<span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">parent</span>	<span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">d</span><span class="o">-&gt;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">second_child</span>	<span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">d</span><span class="o">-&gt;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">second_child</span>	<span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">parent</span>	<span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">d</span><span class="o">-&gt;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">first_child</span>	<span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// if IN has a parent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="nf">is_sibling_internal</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">n</span> <span class="o">=</span> <span class="nf">get_internal_sibling</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">_LOG_</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="s">&#34;internal node is null&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">first_child</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">first_child</span>  <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">parent</span>	   <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">second_child</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">parent</span>	   <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">second_child</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span><span class="o">-&gt;</span><span class="n">parent</span>	   <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">first_child</span>  <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span><span class="o">-&gt;</span><span class="n">parent</span>	   <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="n">n</span><span class="o">-&gt;</span><span class="n">parent</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">n</span><span class="o">-&gt;</span><span class="n">first_child</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">n</span><span class="o">-&gt;</span><span class="n">second_child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">free</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">free</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="cool-fact-about-the-tree">Cool fact about the tree.<a hidden class="anchor" aria-hidden="true" href="#cool-fact-about-the-tree">#</a></h2>
<p>Hopefully, by now, you can see that continuously opening windows on one side of the screen won&rsquo;t result in an extremely skewed tree forming a linked list. This is because BSP tree nodes can <strong>ONLY</strong> have two or zero children.</p>
<p>But, we can easily end up with an unbalanced tree, we need to write a balancing algorithm to fix it.</p>
<h2 id="the-end">The end<a hidden class="anchor" aria-hidden="true" href="#the-end">#</a></h2>
<p>So, there you have it. Using bsp-trees for managing windows in a tiling window manager isn&rsquo;t just a fancy idea — it actually makes a lot of sense. I had so much fun Implementing this tree into my window manager, I learned a lot and banged my head against the wall more than a few times, but in the end, it was all worth it.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://yazeed1s.github.io/tags/c/">C</a></li>
      <li><a href="https://yazeed1s.github.io/tags/spacial-data-structures/">Spacial Data Structures</a></li>
      <li><a href="https://yazeed1s.github.io/tags/tiling-window-manager/">Tiling Window Manager</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://yazeed1s.github.io/posts/force_memory_cleanup/">
    <span class="title">Next »</span>
    <br>
    <span>Force Memory Cleanup on Crash in C Programs</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
